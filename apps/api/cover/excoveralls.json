{"source_files":[{"name":"lib/mix/tasks/check_oban.ex","source":"defmodule Mix.Tasks.CheckOban do\n  @moduledoc \"\"\"\n  Check Oban job status and diagnostics.\n\n  Usage: mix check_oban [queue_name]\n  \"\"\"\n  use Mix.Task\n\n  @shortdoc \"Check Oban job status\"\n\n  def run([]) do\n    run([\"all\"])\n  end\n\n  def run([queue_name]) do\n    Mix.Task.run(\"app.start\")\n\n    import Ecto.Query\n    alias Emailgator.Repo\n\n    IO.puts(\"\\n=== Oban Job Status ===\")\n\n    queues =\n      if queue_name == \"all\", do: [\"poll\", \"import\", \"archive\", \"unsubscribe\"], else: [queue_name]\n\n    Enum.each(queues, fn queue ->\n      IO.puts(\"\\n--- Queue: #{queue} ---\")\n\n      # Count by state\n      counts =\n        Repo.all(\n          from(j in Oban.Job,\n            where: j.queue == ^queue,\n            select: {fragment(\"?\", j.state), count(j.id)},\n            group_by: j.state\n          )\n        )\n\n      IO.puts(\"Jobs by state:\")\n\n      Enum.each(counts, fn {state, count} ->\n        IO.puts(\"  #{state}: #{count}\")\n      end)\n\n      # Show recent jobs\n      recent =\n        Repo.all(\n          from(j in Oban.Job,\n            where: j.queue == ^queue,\n            order_by: [desc: j.inserted_at],\n            limit: 5,\n            select: %{\n              id: j.id,\n              state: j.state,\n              attempt: j.attempt,\n              inserted_at: j.inserted_at,\n              scheduled_at: j.scheduled_at,\n              errors: fragment(\"array_length(?, 1)\", j.errors)\n            }\n          )\n        )\n\n      if length(recent) > 0 do\n        IO.puts(\"\\nRecent jobs:\")\n\n        Enum.each(recent, fn job ->\n          IO.puts(\n            \"  ID: #{job.id}, State: #{job.state}, Attempt: #{job.attempt}, Errors: #{job.errors}\"\n          )\n\n          IO.puts(\n            \"    Inserted: #{inspect(job.inserted_at)}, Scheduled: #{inspect(job.scheduled_at)}\"\n          )\n        end)\n      end\n    end)\n\n    IO.puts(\"\\n=== Oban Plugins ===\")\n    plugins = Oban.config() |> Keyword.get(:plugins, [])\n\n    Enum.each(plugins, fn plugin ->\n      IO.puts(\"  #{inspect(plugin)}\")\n    end)\n\n    IO.puts(\"\\n=== Oban Queues Configuration ===\")\n    queues_config = Oban.config() |> Keyword.get(:queues, [])\n\n    Enum.each(queues_config, fn {queue, concurrency} ->\n      IO.puts(\"  #{queue}: #{concurrency} concurrent workers\")\n    end)\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,1,null,null,null,4,null,null,null,null,4,null,4,4,null,4,10,null,null,10,null,null,null,null,null,null,null,null,10,null,10,0,null,null,null,10,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,10,0,null,0,0,0,null,null,0,0,null,null,null,null,null,4,4,null,0,0,null,null,0,0,null,0,0,null,null,null]},{"name":"lib/emailgator_web/gettext.ex","source":"defmodule EmailgatorWeb.Gettext do\n  @moduledoc \"\"\"\n  A module providing Internationalization with a gettext-based API.\n\n  By using [Gettext](https://hexdocs.pm/gettext),\n  your module gains a set of macros for translations, for example:\n\n      import EmailgatorWeb.Gettext\n\n      # Simple translation\n      gettext(\"Here is the string to translate\")\n\n      # Plural translation\n      ngettext(\"Here is the string to translate\",\n               \"Here are the strings to translate\",\n               3)\n\n      # Domain-based translation\n      dgettext(\"errors\", \"Here is the error message to translate\")\n\n  See the [Gettext Docs](https://hexdocs.pm/gettext) for detailed usage.\n  \"\"\"\n  use Gettext.Backend, otp_app: :emailgator_api\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"lib/emailgator_web/schema/resolvers/category.ex","source":"defmodule EmailgatorWeb.Schema.Resolvers.Category do\n  alias Emailgator.Categories\n  alias Emailgator.Accounts.User\n\n  def list(_parent, _args, %{context: %{current_user: %User{} = user}}) do\n    {:ok, Categories.list_user_categories(user.id)}\n  end\n\n  def list(_parent, _args, _context) do\n    {:error, \"Not authenticated\"}\n  end\n\n  def get(_parent, %{id: id}, %{context: %{current_user: user}}) when not is_nil(user) do\n    case Categories.get_category(id) do\n      nil -> {:error, \"Category not found\"}\n      category -> {:ok, category}\n    end\n  end\n\n  def get(_parent, _args, _context) do\n    {:error, \"Not authenticated\"}\n  end\n\n  def create(_parent, args, %{context: %{current_user: %User{} = user}}) do\n    args\n    |> Map.put(:user_id, user.id)\n    |> Categories.create_category()\n  end\n\n  def create(_parent, _args, _context) do\n    {:error, \"Not authenticated\"}\n  end\n\n  def update(_parent, %{id: id} = args, %{context: %{current_user: user}})\n      when not is_nil(user) do\n    case Categories.get_category(id) do\n      nil -> {:error, \"Category not found\"}\n      category -> Categories.update_category(category, args)\n    end\n  end\n\n  def update(_parent, _args, _context) do\n    {:error, \"Not authenticated\"}\n  end\n\n  def delete(_parent, %{id: id}, %{context: %{current_user: user}}) when not is_nil(user) do\n    case Categories.get_category(id) do\n      nil -> {:error, \"Category not found\"}\n      category -> Categories.delete_category(category)\n    end\n  end\n\n  def delete(_parent, _args, _context) do\n    {:error, \"Not authenticated\"}\n  end\nend","coverage":[null,null,null,null,3,3,null,null,1,null,null,null,null,5,2,3,null,null,null,1,null,null,null,null,null,3,3,null,null,1,null,null,null,null,null,2,1,1,null,null,null,1,null,null,null,null,2,1,1,null,null,null,1,null,null,null]},{"name":"lib/emailgator/jobs/poll_cron.ex","source":"defmodule Emailgator.Jobs.PollCron do\n  @moduledoc \"\"\"\n  Oban cron job that triggers polling for all active accounts.\n  Runs every 2 minutes.\n  \"\"\"\n  use Oban.Worker, queue: :poll, max_attempts: 1\n\n  @impl Oban.Worker\n  def perform(_job) do\n    alias Emailgator.Accounts\n    alias Emailgator.Jobs.PollInbox\n\n    require Logger\n\n    Logger.info(\"PollCron: Starting scheduled poll for all active accounts\")\n\n    accounts = Accounts.list_active_accounts()\n    Logger.info(\"PollCron: Found #{length(accounts)} active account(s)\")\n\n    accounts\n    |> Enum.each(fn account ->\n      Logger.info(\"PollCron: Queuing PollInbox job for account #{account.id}\")\n\n      %{account_id: account.id}\n      |> PollInbox.new()\n      |> Oban.insert()\n    end)\n\n    Logger.info(\"PollCron: Completed scheduled poll\")\n    :ok\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,8,null,8,8,null,null,8,11,null,11,null,11,null,null,8,null,null,null]},{"name":"lib/emailgator_web.ex","source":"defmodule EmailgatorWeb do\n  @moduledoc \"\"\"\n  The entrypoint for defining your web interface.\n\n  This defines the helpers for controllers, views, router, etc.\n  \"\"\"\n  def controller do\n    quote do\n      use Phoenix.Controller, namespace: EmailgatorWeb\n      import Plug.Conn\n      import EmailgatorWeb.Gettext\n      action_fallback(EmailgatorWeb.FallbackController)\n    end\n  end\n\n  def router do\n    quote do\n      use Phoenix.Router\n      import Plug.Conn\n      import Phoenix.Controller\n    end\n  end\n\n  def channel do\n    quote do\n      use Phoenix.Channel\n      import EmailgatorWeb.Gettext\n    end\n  end\n\n  @doc \"\"\"\n  When used, dispatch to the appropriate controller/view/etc.\n  \"\"\"\n  defmacro __using__(which) when is_atom(which) do\n    apply(__MODULE__, which, [])\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null]},{"name":"lib/emailgator/jobs/unsubscribe.ex","source":"defmodule Emailgator.Jobs.Unsubscribe do\n  @moduledoc \"\"\"\n  Attempts to unsubscribe from an email using the Playwright sidecar service.\n  The sidecar handles both simple unsubscribe links and complex forms.\n  \"\"\"\n  use Oban.Worker, queue: :unsubscribe, max_attempts: 2\n  alias Emailgator.{Emails, Unsubscribe}\n\n  require Logger\n\n  @impl Oban.Worker\n  def perform(%Oban.Job{args: %{\"email_id\" => email_id}}) do\n    require Logger\n    Logger.info(\"Unsubscribe: Starting unsubscribe job for email #{email_id}\")\n\n    case Emails.get_email_with_account(email_id) do\n      nil ->\n        Logger.error(\"Unsubscribe: Email #{email_id} not found\")\n        {:cancel, \"Email not found\"}\n\n      email ->\n        unsubscribe_urls = email.unsubscribe_urls || []\n\n        # Step 1: Check if unsubscribe_urls exist\n        # Step 2: If no, try extracting from body_html\n        # Step 3: If URLs exist, continue with existing flow\n        final_urls =\n          if Enum.empty?(unsubscribe_urls) do\n            Logger.info(\"Unsubscribe: No unsubscribe URLs in database, extracting from HTML\")\n\n            # Step 2: Try extracting from body_html\n            html_urls = extract_unsubscribe_from_html(email.body_html || \"\")\n\n            if Enum.empty?(html_urls) do\n              Logger.warning(\n                \"Unsubscribe: Email #{email_id} has no unsubscribe URLs in database or HTML\"\n              )\n\n              # Create attempt record even when no URLs found, so user knows why it failed\n              # Use a placeholder URL since the column is not null\n              case Unsubscribe.create_attempt(%{\n                     email_id: email.id,\n                     method: \"none\",\n                     url: \"none://no-unsubscribe-url-found\",\n                     status: \"failed\",\n                     evidence: %{error: \"No unsubscribe URLs found in email or HTML body\"}\n                   }) do\n                {:ok, attempt} ->\n                  Logger.info(\n                    \"Unsubscribe: Created attempt record #{attempt.id} for email with no URLs\"\n                  )\n\n                {:error, changeset} ->\n                  Logger.error(\n                    \"Unsubscribe: Failed to create attempt record: #{inspect(changeset.errors)}\"\n                  )\n              end\n\n              {:error, \"No unsubscribe URLs found\"}\n            else\n              Logger.info(\n                \"Unsubscribe: Found #{length(html_urls)} unsubscribe URL(s) in HTML body\"\n              )\n\n              html_urls\n            end\n          else\n            Logger.info(\n              \"Unsubscribe: Found #{length(unsubscribe_urls)} unsubscribe URL(s) for email #{email_id}\"\n            )\n\n            unsubscribe_urls\n          end\n\n        # Step 3: If URLs exist, continue with existing flow\n        case final_urls do\n          {:error, _reason} = error ->\n            error\n\n          urls when is_list(urls) and length(urls) > 0 ->\n            attempt_unsubscribe(email, urls)\n\n          _ ->\n            {:error, \"No unsubscribe URLs to process\"}\n        end\n    end\n  end\n\n  defp attempt_unsubscribe(email, [url | rest]) do\n    require Logger\n\n    Logger.info(\n      \"Unsubscribe: Attempting to unsubscribe from #{url} for email #{email.id} (using sidecar)\"\n    )\n\n    # Always use Playwright sidecar for all unsubscribe attempts\n    # This ensures we can handle both simple links and forms, and verify actual success\n    case try_playwright_unsubscribe(url) do\n      {:ok, evidence} ->\n        Logger.info(\"Unsubscribe: Sidecar unsubscribe successful for email #{email.id}\")\n\n        Unsubscribe.create_attempt(%{\n          email_id: email.id,\n          method: \"playwright\",\n          url: url,\n          status: \"success\",\n          evidence: evidence\n        })\n\n        :ok\n\n      {:error, reason} ->\n        Logger.warning(\"Unsubscribe: Sidecar failed for email #{email.id}: #{inspect(reason)}\")\n\n        # Try next URL if available\n        if Enum.empty?(rest) do\n          Unsubscribe.create_attempt(%{\n            email_id: email.id,\n            method: \"playwright\",\n            url: url,\n            status: \"failed\",\n            evidence: %{error: inspect(reason)}\n          })\n\n          {:error, \"All unsubscribe attempts failed\"}\n        else\n          attempt_unsubscribe(email, rest)\n        end\n    end\n  end\n\n  defp attempt_unsubscribe(_email, []) do\n    {:error, \"No unsubscribe URLs to try\"}\n  end\n\n  defp extract_unsubscribe_from_html(html) when is_binary(html) and html != \"\" do\n    require Logger\n\n    # Extract all href URLs from anchor tags (handle both single and double quotes)\n    href_pattern = ~r/href\\s*=\\s*[\"']([^\"']+)[\"']/i\n\n    urls =\n      Regex.scan(href_pattern, html)\n      |> Enum.map(fn [_, url] -> url end)\n      # Decode HTML entities (basic ones)\n      |> Enum.map(&decode_html_entities/1)\n      |> Enum.map(&String.trim/1)\n      |> Enum.filter(fn url ->\n        # Filter for unsubscribe-related URLs\n        url_lower = String.downcase(url)\n\n        String.contains?(url_lower, [\n          \"unsubscribe\",\n          \"opt-out\",\n          \"optout\",\n          \"opt_out\",\n          \"manage.preferences\",\n          \"email.preferences\",\n          \"preference\",\n          \"berhenti\",\n          \"cancel.subscription\",\n          \"remove.me\",\n          # Indonesian keywords for subscription management\n          # subscription\n          \"langganan\",\n          # subscription settings\n          \"pengaturan.langganan\",\n          # change settings\n          \"ubah.pengaturan\",\n          # manage subscription\n          \"kelola.langganan\",\n          # stop subscription\n          \"hentikan.langganan\"\n        ]) or\n          (String.starts_with?(url, \"mailto:\") and\n             String.contains?(url_lower, [\"unsubscribe\", \"berhenti\", \"langganan\"]))\n      end)\n      |> Enum.filter(fn url ->\n        # Only keep http/https/mailto URLs (filter out javascript:, data:, etc.)\n        String.starts_with?(url, \"http://\") or\n          String.starts_with?(url, \"https://\") or\n          String.starts_with?(url, \"mailto:\")\n      end)\n      |> Enum.uniq()\n\n    Logger.info(\"Unsubscribe: Extracted #{length(urls)} unsubscribe URL(s) from HTML\")\n    urls\n  end\n\n  defp extract_unsubscribe_from_html(_), do: []\n\n  # Basic HTML entity decoding\n  defp decode_html_entities(url) do\n    url\n    |> String.replace(\"&amp;\", \"&\")\n    |> String.replace(\"&lt;\", \"<\")\n    |> String.replace(\"&gt;\", \">\")\n    |> String.replace(\"&quot;\", \"\\\"\")\n    |> String.replace(\"&#39;\", \"'\")\n    |> String.replace(\"&nbsp;\", \" \")\n  end\n\n  defp try_playwright_unsubscribe(url, account_email \\\\ nil) do\n    require Logger\n\n    sidecar_config = Application.get_env(:emailgator_api, :sidecar)\n\n    if is_nil(sidecar_config) do\n      Logger.error(\"Unsubscribe: Sidecar configuration not found\")\n      {:error, \"Sidecar configuration missing\"}\n    else\n      sidecar_url = Keyword.get(sidecar_config, :url)\n      token = Keyword.get(sidecar_config, :token)\n\n      if is_nil(sidecar_url) or is_nil(token) do\n        Logger.error(\n          \"Unsubscribe: Sidecar URL or token missing. URL: #{inspect(sidecar_url)}, Token: #{if token, do: \"[REDACTED]\", else: \"nil\"}\"\n        )\n\n        {:error, \"Sidecar configuration incomplete\"}\n      else\n        Logger.info(\"Unsubscribe: Calling sidecar at #{sidecar_url}/run for URL: #{url}\")\n\n        if account_email do\n          Logger.info(\"Unsubscribe: Passing account email to sidecar: #{account_email}\")\n        end\n\n        Logger.info(\n          \"Unsubscribe: Token length: #{String.length(to_string(token))}, first 4 chars: #{String.slice(to_string(token), 0..3)}...\"\n        )\n\n        # Use Task with timeout to prevent hanging requests (90s timeout for Playwright)\n        task =\n          Task.async(fn ->\n            try do\n              # Use Finch directly with explicit timeout (90s for sidecar operations)\n              body = %{url: url}\n              body = if account_email, do: Map.put(body, :email, account_email), else: body\n              body_json = Jason.encode!(body)\n\n              request =\n                Finch.build(\n                  :post,\n                  \"#{sidecar_url}/run\",\n                  [{\"content-type\", \"application/json\"}, {\"x-internal\", token}],\n                  body_json\n                )\n\n              result = Finch.request(request, Emailgator.Finch, receive_timeout: 90_000)\n\n              # Convert Finch response to Tesla response format for compatibility\n              case result do\n                {:ok, %Finch.Response{status: status, body: body}} ->\n                  # Parse JSON body\n                  body_map =\n                    case Jason.decode(body) do\n                      {:ok, decoded} -> decoded\n                      {:error, _} -> body\n                    end\n\n                  # Convert to Tesla.Env format\n                  tesla_env = %Tesla.Env{\n                    status: status,\n                    body: body_map\n                  }\n\n                  {:ok, tesla_env}\n\n                {:error, reason} ->\n                  {:error, reason}\n              end\n            rescue\n              e ->\n                Logger.error(\"Unsubscribe: Exception in Task: #{inspect(e)}\")\n                {:error, inspect(e)}\n            catch\n              :exit, reason ->\n                Logger.error(\"Unsubscribe: Task exited: #{inspect(reason)}\")\n                {:error, inspect(reason)}\n            end\n          end)\n\n        Logger.debug(\"Unsubscribe: Waiting for sidecar response with 90s timeout...\")\n\n        result =\n          case Task.yield(task, 90_000) || Task.shutdown(task) do\n            {:ok,\n             {:ok,\n              %Tesla.Env{\n                status: 200,\n                body: %{\n                  \"ok\" => true,\n                  \"status\" => status,\n                  \"screenshot_b64\" => screenshot,\n                  \"actions\" => actions\n                }\n              }}} ->\n              Logger.info(\"Unsubscribe: Sidecar returned success with status: #{status}\")\n\n              evidence = %{\n                status: status,\n                screenshot: screenshot,\n                actions: actions || []\n              }\n\n              {:ok, evidence}\n\n            {:ok, {:ok, %Tesla.Env{status: 200, body: body}}} when is_map(body) ->\n              # Handle older response format or responses without all fields\n              status = Map.get(body, \"status\", \"unknown\")\n              screenshot = Map.get(body, \"screenshot_b64\", \"\")\n              actions = Map.get(body, \"actions\", [])\n\n              Logger.info(\n                \"Unsubscribe: Sidecar returned success (legacy format) with status: #{status}\"\n              )\n\n              evidence = %{\n                status: status,\n                screenshot: screenshot,\n                actions: actions\n              }\n\n              {:ok, evidence}\n\n            {:ok, {:ok, %Tesla.Env{status: status, body: body}}} ->\n              Logger.error(\n                \"Unsubscribe: Sidecar returned error status #{status}: #{inspect(body)}\"\n              )\n\n              {:error, \"Sidecar returned status #{status}: #{inspect(body)}\"}\n\n            {:ok, {:error, reason}} ->\n              Logger.error(\"Unsubscribe: Sidecar request error: #{inspect(reason)}\")\n              {:error, inspect(reason)}\n\n            nil ->\n              Logger.error(\"Unsubscribe: Sidecar request timed out after 90 seconds\")\n\n              {:error,\n               \"Sidecar request timed out - is the sidecar running? (Check sidecar logs for progress)\"}\n\n            {:exit, reason} ->\n              Logger.error(\"Unsubscribe: Task exited: #{inspect(reason)}\")\n              {:error, \"Request task failed\"}\n          end\n\n        Logger.debug(\"Unsubscribe: Sidecar task result: #{inspect(result)}\")\n        result\n      end\n    end\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,19,null,19,null,1,null,null,null,18,null,null,null,null,18,7,15,null,null,15,null,15,7,7,null,null,null,null,7,7,null,null,null,null,null,null,7,0,null,null,null,0,0,null,null,null,null,null,8,0,null,null,8,null,null,3,0,null,null,3,null,null,null,18,null,7,null,null,11,null,0,null,null,null,null,null,null,null,null,17,0,null,null,null,null,17,null,0,null,0,0,null,null,null,null,null,null,null,null,null,17,null,null,17,11,11,null,null,null,null,null,null,null,null,6,null,null,null,null,0,null,null,null,null,null,null,null,12,null,12,null,20,null,null,null,null,null,20,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,20,7,0,null,null,null,0,13,2,null,null,null,12,12,null,null,3,null,null,null,null,null,null,null,null,null,20,null,null,null,null,null,17,null,17,0,null,null,17,17,null,17,0,0,null,null,null,null,17,null,17,0,null,null,17,0,null,null,null,17,null,17,null,17,17,17,null,17,null,null,17,null,null,null,null,17,null,null,17,null,null,0,null,0,0,null,null,null,0,null,null,null,null,null,null,17,null,null,null,0,0,null,null,null,0,null,null,null,null,17,null,17,17,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,0,null,null,null,null,null,null,0,0,0,null,0,0,null,null,0,null,null,null,null,null,null,null,null,0,0,null,null,0,null,null,17,null,null,null,0,null,null,null,null,null,0,null,null,null,17,17,null,null,null,null]},{"name":"lib/emailgator/categories/category.ex","source":"defmodule Emailgator.Categories.Category do\n  use Ecto.Schema\n  import Ecto.Changeset\n  alias Emailgator.Accounts.User\n\n  @primary_key {:id, :binary_id, autogenerate: true}\n  @foreign_key_type :binary_id\n\n  schema \"categories\" do\n    field(:name, :string)\n    field(:description, :string)\n    belongs_to(:user, User)\n\n    has_many(:emails, Emailgator.Emails.Email)\n\n    timestamps()\n  end\n\n  @doc false\n  def changeset(category, attrs) do\n    category\n    |> cast(attrs, [:name, :description, :user_id])\n    |> validate_required([:name, :user_id])\n    |> validate_length(:name, min: 1, max: 255)\n  end\nend","coverage":[null,null,null,null,null,null,null,null,2015,null,null,null,null,null,null,null,null,null,null,null,null,null,null,215,null,null]},{"name":"lib/emailgator/accounts.ex","source":"defmodule Emailgator.Accounts do\n  @moduledoc \"\"\"\n  Context for managing users and Gmail accounts.\n  \"\"\"\n  import Ecto.Query\n  alias Emailgator.Repo\n  alias Emailgator.Accounts.{User, Account}\n\n  # Users\n\n  def get_user(id), do: Repo.get(User, id)\n  def get_user_by_email(email), do: Repo.get_by(User, email: email)\n\n  def create_or_update_user(attrs) do\n    case get_user_by_email(attrs[\"email\"]) do\n      nil -> create_user(attrs)\n      user -> update_user(user, attrs)\n    end\n  end\n\n  def create_user(attrs \\\\ %{}) do\n    %User{}\n    |> User.changeset(attrs)\n    |> Repo.insert()\n  end\n\n  def update_user(%User{} = user, attrs) do\n    user\n    |> User.changeset(attrs)\n    |> Repo.update()\n  end\n\n  # Accounts (Gmail)\n\n  def list_user_accounts(user_id) do\n    from(a in Account, where: a.user_id == ^user_id)\n    |> Repo.all()\n  end\n\n  def get_account(id), do: Repo.get(Account, id)\n\n  def get_account_by_email(user_id, email),\n    do: Repo.get_by(Account, user_id: user_id, email: email)\n\n  def create_account(attrs \\\\ %{}) do\n    %Account{}\n    |> Account.changeset(attrs)\n    |> Repo.insert()\n  end\n\n  def update_account(%Account{} = account, attrs) do\n    account\n    |> Account.changeset(attrs)\n    |> Repo.update()\n  end\n\n  def delete_account(%Account{} = account) do\n    Repo.delete(account)\n  end\n\n  def list_active_accounts do\n    from(a in Account, where: not is_nil(a.refresh_token))\n    |> Repo.all()\n  end\n\n  @doc \"\"\"\n  Get account with valid access token, refreshing if needed.\n  \"\"\"\n  def get_account_with_valid_token(account_id) do\n    require Logger\n    Logger.info(\"Accounts.get_account_with_valid_token: Called for account_id: #{account_id}\")\n\n    case get_account(account_id) do\n      nil ->\n        Logger.warning(\"Accounts.get_account_with_valid_token: Account #{account_id} not found\")\n        nil\n\n      account ->\n        Logger.info(\n          \"Accounts.get_account_with_valid_token: Found account, checking token expiration. expires_at: #{inspect(account.expires_at)}\"\n        )\n\n        if token_expired?(account) do\n          Logger.info(\"Accounts.get_account_with_valid_token: Token expired, refreshing...\")\n          refresh_account_token(account)\n        else\n          Logger.info(\"Accounts.get_account_with_valid_token: Token is valid, returning account\")\n          {:ok, account}\n        end\n    end\n  end\n\n  defp token_expired?(%Account{} = account) do\n    case account.expires_at do\n      nil ->\n        true\n\n      expires_at ->\n        comparison = DateTime.compare(DateTime.utc_now(), expires_at)\n        expired = comparison != :lt\n        expired\n    end\n  end\n\n  defp refresh_account_token(%Account{} = account) do\n    require Logger\n\n    Logger.info(\n      \"Accounts.refresh_account_token: Starting token refresh for account #{account.id}\"\n    )\n\n    case Emailgator.Gmail.refresh_token(account) do\n      {:ok, new_token, expires_at} ->\n        Logger.info(\"Accounts.refresh_account_token: Token refresh successful, updating account\")\n\n        case update_account(account, %{\n               access_token: new_token,\n               expires_at: expires_at\n             }) do\n          {:ok, updated_account} ->\n            Logger.info(\"Accounts.refresh_account_token: Account updated successfully\")\n            {:ok, updated_account}\n\n          {:error, reason} = error ->\n            Logger.error(\n              \"Accounts.refresh_account_token: Failed to update account: #{inspect(reason)}\"\n            )\n\n            error\n        end\n\n      {:error, reason} = error ->\n        Logger.error(\"Accounts.refresh_account_token: Token refresh failed: #{inspect(reason)}\")\n        error\n    end\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,5,10,null,null,6,3,3,null,null,null,null,null,null,373,null,null,null,null,null,7,null,null,null,null,null,null,14,null,null,199,null,null,6,null,null,null,null,250,null,null,null,null,null,14,null,null,null,7,null,null,null,null,10,null,null,null,null,null,null,null,98,null,98,null,5,null,null,null,93,0,null,null,93,9,9,null,84,null,null,null,null,null,null,93,2,null,null,null,91,91,91,null,null,null,null,null,null,9,0,null,null,9,null,0,null,0,null,null,null,null,0,null,null,null,0,null,null,null,0,null,null,null,9,9,null,null,null]},{"name":"lib/emailgator/repo.ex","source":"defmodule Emailgator.Repo do\n  use Ecto.Repo,\n    otp_app: :emailgator_api,\n    adapter: Ecto.Adapters.Postgres\nend","coverage":[null,null,null,null,null]},{"name":"lib/emailgator_web/controllers/fallback_controller.ex","source":"defmodule EmailgatorWeb.FallbackController do\n  use EmailgatorWeb, :controller\n\n  def call(conn, {:error, %Ecto.Changeset{} = changeset}) do\n    conn\n    |> put_status(:unprocessable_entity)\n    |> put_view(json: EmailgatorWeb.ErrorJSON)\n    |> render(:error, changeset: changeset)\n  end\n\n  def call(conn, {:error, :not_found}) do\n    conn\n    |> put_status(:not_found)\n    |> put_view(json: EmailgatorWeb.ErrorJSON)\n    |> render(:\"404\")\n  end\n\n  def call(conn, {:error, :unauthorized}) do\n    conn\n    |> put_status(:unauthorized)\n    |> put_view(json: EmailgatorWeb.ErrorJSON)\n    |> render(:\"401\")\n  end\nend","coverage":[null,null,null,null,null,null,null,2,null,null,null,null,null,null,1,null,null,null,null,null,null,1,null,null]},{"name":"lib/emailgator/application.ex","source":"defmodule Emailgator.Application do\n  @moduledoc false\n  use Application\n\n  @impl true\n  def start(_type, _args) do\n    children = [\n      Emailgator.Repo,\n      {Phoenix.PubSub, name: Emailgator.PubSub},\n      EmailgatorWeb.Endpoint,\n      {Oban, Application.get_env(:emailgator_api, Oban)},\n      {Finch, name: Emailgator.Finch}\n    ]\n\n    opts = [strategy: :one_for_one, name: Emailgator.Supervisor]\n    Supervisor.start_link(children, opts)\n  end\n\n  @impl true\n  def config_change(changed, _new, removed) do\n    EmailgatorWeb.Endpoint.config_change(changed, removed)\n    :ok\n  end\nend","coverage":[null,null,null,null,null,null,1,null,null,null,null,null,null,null,1,1,null,null,null,null,1,null,null,null]},{"name":"lib/emailgator_web/error_json.ex","source":"defmodule EmailgatorWeb.ErrorJSON do\n  def error(%{changeset: changeset}) do\n    %{errors: translate_errors(changeset)}\n  end\n\n  def error(%{message: message}) do\n    %{error: message}\n  end\n\n  def error(%{error: error}) do\n    %{error: error}\n  end\n\n  def render(:\"404\", _assigns), do: %{error: \"Not found\"}\n  def render(\"404.json\", _assigns), do: %{error: \"Not found\"}\n\n  def render(:\"401\", _assigns), do: %{error: \"Unauthorized\"}\n  def render(\"401.json\", _assigns), do: %{error: \"Unauthorized\"}\n\n  defp translate_errors(changeset) do\n    Ecto.Changeset.traverse_errors(changeset, &translate_error/1)\n  end\n\n  defp translate_error({msg, opts}) do\n    Enum.reduce(opts, msg, fn\n      {key, value}, acc ->\n        String.replace(acc, \"%{#{key}}\", to_string(value))\n    end)\n  end\nend","coverage":[null,null,5,null,null,null,1,null,null,null,1,null,null,1,1,null,1,1,null,null,5,null,null,null,7,null,3,null,null,null]},{"name":"lib/emailgator/unsubscribe/unsubscribe_attempt.ex","source":"defmodule Emailgator.Unsubscribe.UnsubscribeAttempt do\n  use Ecto.Schema\n  import Ecto.Changeset\n  alias Emailgator.Emails.Email\n\n  @primary_key {:id, :binary_id, autogenerate: true}\n  @foreign_key_type :binary_id\n\n  schema \"unsubscribe_attempts\" do\n    field(:method, :string)\n    field(:url, :string)\n    field(:status, :string)\n    field(:evidence, :map)\n    belongs_to(:email, Email)\n\n    timestamps()\n  end\n\n  @doc false\n  def changeset(attempt, attrs) do\n    attempt\n    |> cast(attrs, [:method, :url, :status, :evidence, :email_id])\n    |> validate_required([:method, :status, :email_id])\n    |> validate_inclusion(:status, [\"success\", \"failed\"])\n    |> validate_inclusion(:method, [\"http\", \"playwright\", \"none\"])\n  end\nend","coverage":[null,null,null,null,null,null,null,null,517,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,42,null,null]},{"name":"lib/emailgator_web/schema/resolvers/email.ex","source":"defmodule EmailgatorWeb.Schema.Resolvers.Email do\n  alias Emailgator.{Emails, Repo}\n  alias Emailgator.Jobs.Unsubscribe, as: UnsubscribeJob\n  alias Emailgator.Unsubscribe\n  alias Emailgator.Unsubscribe.UnsubscribeAttempt\n  import Ecto.Query\n\n  def list_by_category(_parent, %{category_id: category_id}, %{context: %{current_user: user}})\n      when not is_nil(user) do\n    {:ok, Emails.list_category_emails(category_id)}\n  end\n\n  def list_by_category(_parent, _args, _context) do\n    {:error, \"Not authenticated\"}\n  end\n\n  def bulk_delete(_parent, %{email_ids: email_ids}, %{context: %{current_user: user}})\n      when not is_nil(user) do\n    Emails.delete_emails(email_ids)\n    {:ok, email_ids}\n  end\n\n  def bulk_delete(_parent, _args, _context) do\n    {:error, \"Not authenticated\"}\n  end\n\n  def bulk_unsubscribe(_parent, %{email_ids: email_ids}, %{context: %{current_user: user}})\n      when not is_nil(user) do\n    require Logger\n\n    Logger.info(\"bulk_unsubscribe: Queuing #{length(email_ids)} unsubscribe job(s)\")\n\n    # Validate emails exist and belong to user in a single query (more efficient than N+1)\n    user_email_ids =\n      from(e in Emails.Email,\n        join: a in assoc(e, :account),\n        where: e.id in ^email_ids and a.user_id == ^user.id,\n        select: e.id\n      )\n      |> Emailgator.Repo.all()\n\n    invalid_email_ids = email_ids -- user_email_ids\n\n    # Queue jobs in a transaction for better performance with large batches\n    results =\n      Emailgator.Repo.transaction(fn ->\n        user_email_ids\n        |> Enum.map(fn email_id ->\n          case %{email_id: email_id}\n               |> UnsubscribeJob.new()\n               |> Oban.insert() do\n            {:ok, _job} ->\n              %{email_id: email_id, success: true, error: nil}\n\n            {:error, changeset} ->\n              Logger.warning(\n                \"bulk_unsubscribe: Failed to queue job for email #{email_id}: #{inspect(changeset.errors)}\"\n              )\n\n              %{email_id: email_id, success: false, error: \"Failed to queue job\"}\n          end\n        end)\n      end)\n\n    case results do\n      {:ok, valid_results} ->\n        Logger.info(\n          \"bulk_unsubscribe: Successfully queued #{length(valid_results)} unsubscribe job(s)\"\n        )\n\n        invalid_results =\n          Enum.map(invalid_email_ids, fn email_id ->\n            %{email_id: email_id, success: false, error: \"Email not found or access denied\"}\n          end)\n\n        {:ok, valid_results ++ invalid_results}\n\n      {:error, reason} ->\n        Logger.error(\"bulk_unsubscribe: Transaction failed: #{inspect(reason)}\")\n        {:error, \"Failed to queue unsubscribe jobs\"}\n    end\n  end\n\n  def bulk_unsubscribe(_parent, _args, _context) do\n    {:error, \"Not authenticated\"}\n  end\n\n  def get_email(_parent, %{id: email_id}, %{context: %{current_user: %{id: user_id}}}) do\n    # Get email with preloaded account and category to check ownership\n    query =\n      from(e in Emails.Email,\n        join: a in assoc(e, :account),\n        where: e.id == ^email_id and a.user_id == ^user_id,\n        preload: [:account, :category]\n      )\n\n    case Emailgator.Repo.one(query) do\n      nil -> {:error, \"Email not found\"}\n      email -> {:ok, email}\n    end\n  end\n\n  def get_email(_parent, _args, _context) do\n    {:error, \"Not authenticated\"}\n  end\n\n  def is_unsubscribed(%Emails.Email{} = email, _args, _info) do\n    # Check if there's a successful unsubscribe attempt for this email\n    query =\n      from(u in UnsubscribeAttempt,\n        where: u.email_id == ^email.id and u.status == \"success\",\n        limit: 1\n      )\n\n    case Repo.one(query) do\n      nil -> {:ok, false}\n      _attempt -> {:ok, true}\n    end\n  end\n\n  def is_unsubscribed(_parent, _args, _info) do\n    {:ok, false}\n  end\n\n  def unsubscribe_attempts(%Emails.Email{} = email, _args, _info) do\n    attempts = Unsubscribe.list_email_attempts(email.id)\n    {:ok, attempts}\n  end\n\n  def unsubscribe_attempts(_parent, _args, _info) do\n    {:ok, []}\n  end\nend","coverage":[null,null,null,null,null,null,null,2,null,null,null,null,1,null,null,null,null,null,1,null,null,null,1,null,null,null,null,null,null,null,3,null,null,3,3,null,3,null,null,null,null,3,null,null,3,null,null,3,2,null,null,null,2,null,null,0,0,null,null,0,null,null,null,null,3,null,3,0,null,null,3,null,1,null,null,null,null,null,0,null,null,null,null,1,null,null,null,null,null,3,3,null,null,null,null,null,3,2,1,null,null,null,1,null,null,null,null,null,5,null,5,null,null,null,5,4,1,null,null,null,1,null,null,null,null,4,null,null,null,1,null,null,null]},{"name":"lib/emailgator_web/endpoint.ex","source":"defmodule EmailgatorWeb.Endpoint do\n  use Phoenix.Endpoint, otp_app: :emailgator_api\n\n  import Plug.Conn\n\n  plug(Plug.RequestId)\n  plug(Plug.Telemetry, event_prefix: [:phoenix, :endpoint])\n\n  plug(Plug.Parsers,\n    parsers: [:urlencoded, :multipart, :json],\n    pass: [\"*/*\"],\n    json_decoder: Phoenix.json_library()\n  )\n\n  plug(Plug.MethodOverride)\n  plug(Plug.Head)\n\n  # CORS support for frontend (localhost:3000)\n  plug(:cors)\n\n  plug(Plug.Session,\n    store: :cookie,\n    key: \"_emailgator_key\",\n    signing_salt:\n      Application.compile_env(\n        :emailgator_api,\n        [EmailgatorWeb.Endpoint, :signing_salt],\n        \"emailgator_salt\"\n      ),\n    encryption_salt:\n      Application.compile_env(:emailgator_api, :cookie_enc_salt, \"emailgator_enc_salt\")\n    # Note: same_site option removed - CORS headers handle cross-origin cookie sharing\n  )\n\n  plug(EmailgatorWeb.Router)\n\n  # CORS plug handler\n  defp cors(conn, _opts) do\n    frontend_url = System.get_env(\"FRONTEND_URL\") || \"http://localhost:3000\"\n    origin = List.first(get_req_header(conn, \"origin\")) || frontend_url\n\n    # Handle OPTIONS preflight requests\n    if conn.method == \"OPTIONS\" do\n      conn\n      |> put_resp_header(\"access-control-allow-origin\", origin)\n      |> put_resp_header(\"access-control-allow-credentials\", \"true\")\n      |> put_resp_header(\"access-control-allow-methods\", \"GET, POST, PUT, DELETE, OPTIONS\")\n      |> put_resp_header(\"access-control-allow-headers\", \"Content-Type, Authorization\")\n      |> put_resp_header(\"access-control-max-age\", \"3600\")\n      |> send_resp(:no_content, \"\")\n      |> halt()\n    else\n      # Allow requests from frontend URL or any origin in dev\n      allowed_origin =\n        cond do\n          origin == frontend_url -> frontend_url\n          Mix.env() == :dev -> origin\n          true -> frontend_url\n        end\n\n      conn\n      |> put_resp_header(\"access-control-allow-origin\", allowed_origin)\n      |> put_resp_header(\"access-control-allow-credentials\", \"true\")\n      |> put_resp_header(\"access-control-allow-methods\", \"GET, POST, PUT, DELETE, OPTIONS\")\n      |> put_resp_header(\"access-control-allow-headers\", \"Content-Type, Authorization\")\n    end\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,10,10,null,null,10,null,null,null,null,null,null,null,6,null,null,4,null,3,1,1,null,null,null,null,null,null,4,null,null,null]},{"name":"lib/emailgator/categories.ex","source":"defmodule Emailgator.Categories do\n  @moduledoc \"\"\"\n  Context for managing email categories.\n  \"\"\"\n  import Ecto.Query\n  alias Emailgator.Repo\n  alias Emailgator.Categories.Category\n\n  def list_user_categories(user_id) do\n    from(c in Category, where: c.user_id == ^user_id, order_by: [desc: c.inserted_at])\n    |> Repo.all()\n  end\n\n  def get_category(id), do: Repo.get(Category, id)\n  def get_category!(id), do: Repo.get!(Category, id)\n\n  def create_category(attrs \\\\ %{}) do\n    %Category{}\n    |> Category.changeset(attrs)\n    |> Repo.insert()\n  end\n\n  def update_category(%Category{} = category, attrs) do\n    category\n    |> Category.changeset(attrs)\n    |> Repo.update()\n  end\n\n  def delete_category(%Category{} = category) do\n    Repo.delete(category)\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,40,null,null,41,5,null,null,null,null,202,null,null,null,null,null,13,null,null,null,5,null,null]},{"name":"lib/emailgator/accounts/account.ex","source":"defmodule Emailgator.Accounts.Account do\n  use Ecto.Schema\n  import Ecto.Changeset\n  alias Emailgator.Accounts.User\n\n  @primary_key {:id, :binary_id, autogenerate: true}\n  @foreign_key_type :binary_id\n\n  schema \"accounts\" do\n    field(:email, :string)\n    field(:access_token, :string)\n    field(:refresh_token, :string)\n    field(:expires_at, :utc_datetime)\n    field(:last_history_id, :string)\n    belongs_to(:user, User)\n\n    timestamps()\n  end\n\n  @doc false\n  def changeset(account, attrs) do\n    account\n    |> cast(attrs, [\n      :email,\n      :access_token,\n      :refresh_token,\n      :expires_at,\n      :last_history_id,\n      :user_id\n    ])\n    |> validate_required([:email, :access_token, :refresh_token, :user_id])\n    |> validate_format(:email, ~r/^[^\\s]+@[^\\s]+$/, message: \"must be a valid email\")\n    |> unique_constraint([:user_id, :email])\n  end\nend","coverage":[null,null,null,null,null,null,null,null,3526,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,264,null,null]},{"name":"lib/emailgator/unsubscribe.ex","source":"defmodule Emailgator.Unsubscribe do\n  @moduledoc \"\"\"\n  Context for managing unsubscribe attempts.\n  \"\"\"\n  import Ecto.Query\n  alias Emailgator.Repo\n  alias Emailgator.Unsubscribe.UnsubscribeAttempt\n\n  def create_attempt(attrs \\\\ %{}) do\n    %UnsubscribeAttempt{}\n    |> UnsubscribeAttempt.changeset(attrs)\n    |> Repo.insert()\n  end\n\n  def list_email_attempts(email_id) do\n    from(u in UnsubscribeAttempt, where: u.email_id == ^email_id, order_by: [desc: u.inserted_at])\n    |> Repo.all()\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,42,null,null,null,null,27,null,null]},{"name":"lib/emailgator/jobs/import_email.ex","source":"defmodule Emailgator.Jobs.ImportEmail do\n  @moduledoc \"\"\"\n  Imports a single email: fetches from Gmail, classifies with LLM, saves to DB, then archives.\n  \"\"\"\n  use Oban.Worker, queue: :import, max_attempts: 3\n  alias Emailgator.{Accounts, Categories, Emails, Gmail, LLM, Jobs.ArchiveEmail}\n\n  require Logger\n\n  @impl Oban.Worker\n  def perform(%Oban.Job{args: %{\"account_id\" => account_id, \"message_id\" => message_id}}) do\n    Logger.info(\"ImportEmail: Starting import for message #{message_id}, account #{account_id}\")\n\n    account = Accounts.get_account(account_id)\n\n    if is_nil(account) do\n      Logger.error(\"ImportEmail: Account #{account_id} not found\")\n      {:cancel, \"Account not found\"}\n    else\n      # Check if email already imported\n      if Emails.get_email_by_gmail_id(account_id, message_id) do\n        Logger.info(\"ImportEmail: Message #{message_id} already imported, skipping\")\n        :ok\n      else\n        Logger.info(\"ImportEmail: Importing new message #{message_id}\")\n        import_email(account, message_id)\n      end\n    end\n  end\n\n  defp import_email(account, message_id) do\n    Logger.info(\"ImportEmail: Step 1 - Fetching message from Gmail API\")\n\n    case Gmail.get_message(account.id, message_id) do\n      {:ok, gmail_message} ->\n        Logger.info(\"ImportEmail: Step 2 - Extracting email data\")\n\n        case extract_email_data(gmail_message) do\n          {:ok, email_data} ->\n            Logger.info(\"ImportEmail: Step 3 - Classifying email with LLM\")\n\n            case classify_email(account.user_id, email_data) do\n              {:ok, category, summary, llm_urls} ->\n                Logger.info(\"ImportEmail: Step 4 - Combining unsubscribe URLs\")\n\n                # Combine header URLs with LLM-extracted URLs\n                header_urls = Map.get(email_data, :header_unsubscribe_urls, [])\n                all_unsubscribe_urls = (header_urls ++ llm_urls) |> Enum.uniq()\n\n                Logger.info(\n                  \"ImportEmail: Found #{length(header_urls)} header URL(s) and #{length(llm_urls)} LLM URL(s), total: #{length(all_unsubscribe_urls)}\"\n                )\n\n                case save_email(\n                       account,\n                       category,\n                       email_data,\n                       message_id,\n                       summary,\n                       all_unsubscribe_urls\n                     ) do\n                  {:ok, _email} ->\n                    Logger.info(\"ImportEmail: Step 5 - Queuing archive job\")\n\n                    case queue_archive(account.id, message_id) do\n                      {:ok, _} ->\n                        Logger.info(\"ImportEmail: Successfully imported message #{message_id}\")\n                        :ok\n\n                      {:error, reason} ->\n                        Logger.warning(\n                          \"ImportEmail: Import succeeded but archive queue failed: #{inspect(reason)}\"\n                        )\n\n                        # Still return :ok since email was imported\n                        :ok\n                    end\n\n                  {:error, reason} ->\n                    Logger.error(\"ImportEmail: Failed to save email: #{inspect(reason)}\")\n                    {:error, \"Import failed at save: #{inspect(reason)}\"}\n                end\n\n              {:error, {:rate_limit, _}} ->\n                Logger.warning(\"ImportEmail: Rate limited, snoozing for 20 seconds\")\n                {:snooze, 20}\n\n              {:error, reason} ->\n                Logger.error(\"ImportEmail: Failed to classify email: #{inspect(reason)}\")\n                {:error, \"Import failed at classification: #{inspect(reason)}\"}\n            end\n\n          {:error, reason} ->\n            Logger.error(\"ImportEmail: Failed to extract email data: #{inspect(reason)}\")\n            {:error, \"Import failed at extraction: #{inspect(reason)}\"}\n        end\n\n      {:error, reason} ->\n        Logger.error(\"ImportEmail: Failed to fetch message from Gmail: #{inspect(reason)}\")\n        {:error, \"Import failed at Gmail fetch: #{inspect(reason)}\"}\n    end\n  end\n\n  defp extract_email_data(%{\"payload\" => payload, \"snippet\" => snippet, \"id\" => id}) do\n    try do\n      subject = get_header(payload, \"Subject\")\n      from = get_header(payload, \"From\")\n      body_text = extract_body_text(payload)\n      body_html = extract_body_html(payload)\n\n      # Extract unsubscribe URLs from email headers (List-Unsubscribe header)\n      header_unsubscribe_urls = extract_unsubscribe_from_headers(payload)\n\n      {:ok,\n       %{\n         subject: subject,\n         from: from,\n         snippet: snippet,\n         body_text: body_text,\n         body_html: body_html,\n         gmail_message_id: id,\n         header_unsubscribe_urls: header_unsubscribe_urls\n       }}\n    rescue\n      e ->\n        Logger.error(\"ImportEmail: Failed to extract email data: #{inspect(e)}\")\n        {:error, \"Failed to extract email data: #{inspect(e)}\"}\n    end\n  end\n\n  defp extract_email_data(_invalid_message) do\n    {:error, \"Invalid message format\"}\n  end\n\n  defp get_header(payload, name) do\n    headers = Map.get(payload, \"headers\", [])\n    Enum.find_value(headers, fn %{\"name\" => n, \"value\" => v} -> if n == name, do: v end) || \"\"\n  end\n\n  defp extract_unsubscribe_from_headers(payload) do\n    list_unsubscribe = get_header(payload, \"List-Unsubscribe\")\n    list_unsubscribe_post = get_header(payload, \"List-Unsubscribe-Post\")\n\n    urls = []\n\n    # Parse List-Unsubscribe header - can contain mailto: or http(s):// URLs\n    urls =\n      if list_unsubscribe != \"\" do\n        # List-Unsubscribe can have multiple URLs separated by commas, or be in angle brackets\n        list_unsubscribe\n        |> String.split([\",\", \"<\", \">\"])\n        |> Enum.map(&String.trim/1)\n        |> Enum.filter(fn s ->\n          String.starts_with?(s, \"http://\") or String.starts_with?(s, \"https://\") or\n            String.starts_with?(s, \"mailto:\")\n        end)\n        |> Enum.concat(urls)\n      else\n        urls\n      end\n\n    # List-Unsubscribe-Post header typically doesn't contain URLs, but check just in case\n    urls =\n      if list_unsubscribe_post != \"\" do\n        list_unsubscribe_post\n        |> String.split([\",\", \"<\", \">\"])\n        |> Enum.map(&String.trim/1)\n        |> Enum.filter(fn s ->\n          String.starts_with?(s, \"http://\") or String.starts_with?(s, \"https://\")\n        end)\n        |> Enum.concat(urls)\n      else\n        urls\n      end\n\n    # Also check for List-Unsubscribe headers in nested parts\n    all_headers = get_all_headers(payload)\n\n    list_unsubscribe_parts =\n      all_headers\n      |> Enum.filter(fn %{\"name\" => name} -> name == \"List-Unsubscribe\" end)\n      |> Enum.flat_map(fn %{\"value\" => value} ->\n        value\n        |> String.split([\",\", \"<\", \">\"])\n        |> Enum.map(&String.trim/1)\n        |> Enum.filter(fn s ->\n          String.starts_with?(s, \"http://\") or String.starts_with?(s, \"https://\") or\n            String.starts_with?(s, \"mailto:\")\n        end)\n      end)\n\n    (urls ++ list_unsubscribe_parts)\n    |> Enum.uniq()\n    |> Enum.filter(&(&1 != \"\"))\n  end\n\n  defp get_all_headers(payload) do\n    headers = Map.get(payload, \"headers\", [])\n\n    # Also check headers in nested parts\n    parts = Map.get(payload, \"parts\", [])\n    part_headers = Enum.flat_map(parts, &Map.get(&1, \"headers\", []))\n\n    headers ++ part_headers\n  end\n\n  defp extract_body_text(payload) do\n    case get_body_part(payload, \"text/plain\") do\n      nil ->\n        \"\"\n\n      \"\" ->\n        \"\"\n\n      data ->\n        # Gmail API uses Base64url encoding (RFC 4648 ยง5)\n        case Base.url_decode64(data) do\n          {:ok, decoded} ->\n            String.trim(decoded)\n\n          :error ->\n            # Fallback to standard Base64 if url_decode fails\n            try do\n              Base.decode64!(data) |> String.trim()\n            rescue\n              _e -> \"\"\n            end\n        end\n    end\n  end\n\n  defp extract_body_html(payload) do\n    case get_body_part(payload, \"text/html\") do\n      nil ->\n        \"\"\n\n      \"\" ->\n        \"\"\n\n      data ->\n        # Gmail API uses Base64url encoding (RFC 4648 ยง5)\n        case Base.url_decode64(data) do\n          {:ok, decoded} ->\n            String.trim(decoded)\n\n          :error ->\n            # Fallback to standard Base64 if url_decode fails\n            try do\n              Base.decode64!(data) |> String.trim()\n            rescue\n              _e -> \"\"\n            end\n        end\n    end\n  end\n\n  defp get_body_part(payload, mime_type) do\n    parts = Map.get(payload, \"parts\", [])\n\n    part =\n      Enum.find(parts, fn part ->\n        Map.get(part, \"mimeType\") == mime_type\n      end)\n\n    case part do\n      nil ->\n        # Try top-level body\n        if Map.get(payload, \"mimeType\") == mime_type do\n          Map.get(payload, \"body\", %{}) |> Map.get(\"data\")\n        else\n          nil\n        end\n\n      part ->\n        Map.get(part, \"body\", %{}) |> Map.get(\"data\")\n    end\n  end\n\n  defp classify_email(user_id, email_data) do\n    categories = Categories.list_user_categories(user_id)\n\n    if Enum.empty?(categories) do\n      {:error, \"No categories defined\"}\n    else\n      case LLM.classify_and_summarize(email_data, email_data.body_text, categories) do\n        {:ok, %{category_id: category_id, summary: summary, unsubscribe_urls: urls}} ->\n          category = Categories.get_category(category_id)\n          {:ok, category, summary, urls}\n\n        {:error, {:rate_limit, _body}} ->\n          # Rate limit error - return special error to trigger retry with backoff\n          Logger.warning(\"ImportEmail: OpenAI rate limit hit, job will retry with backoff\")\n          {:error, {:rate_limit, \"OpenAI rate limit exceeded\"}}\n\n        {:error, _reason} ->\n          # Fallback to first category for other errors\n          Logger.warning(\"ImportEmail: LLM classification failed, using fallback category\")\n          first_category = List.first(categories)\n          {:ok, first_category, \"Unable to generate summary\", []}\n      end\n    end\n  end\n\n  defp save_email(account, category, email_data, message_id, summary, unsubscribe_urls) do\n    Emails.create_email(%{\n      account_id: account.id,\n      category_id: category.id,\n      gmail_message_id: message_id,\n      subject: email_data.subject,\n      from: email_data.from,\n      snippet: email_data.snippet,\n      summary: summary,\n      body_text: email_data.body_text,\n      body_html: email_data.body_html,\n      unsubscribe_urls: unsubscribe_urls\n    })\n  end\n\n  defp queue_archive(account_id, message_id) do\n    case %{account_id: account_id, message_id: message_id}\n         |> ArchiveEmail.new()\n         |> Oban.insert() do\n      {:ok, _job} ->\n        {:ok, :queued}\n\n      {:error, reason} ->\n        Logger.warning(\"ImportEmail: Failed to queue archive job: #{inspect(reason)}\")\n        {:error, \"Failed to queue archive: #{inspect(reason)}\"}\n    end\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,42,null,42,null,42,2,null,null,null,40,4,null,null,36,36,null,null,null,null,null,36,null,36,null,33,null,33,null,28,null,28,null,24,null,null,24,24,null,24,0,null,null,24,null,null,null,null,null,null,null,null,24,null,24,null,24,null,null,null,0,null,null,null,null,null,null,null,null,0,null,null,null,null,2,null,null,null,2,null,null,null,null,5,null,null,null,null,3,null,null,null,null,null,28,28,28,28,28,null,null,28,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,5,null,null,null,null,112,112,null,null,null,28,28,null,28,null,null,28,null,null,null,null,null,null,33,26,null,7,null,21,null,null,null,28,null,null,null,null,null,6,null,2,null,26,null,null,null,28,null,28,null,65,null,null,null,null,9,39,30,null,null,null,null,null,28,null,null,null,28,null,null,28,28,null,28,null,null,null,28,9,null,null,1,null,null,null,null,18,null,18,null,null,null,0,0,null,0,null,null,null,null,null,null,28,26,null,null,0,null,null,null,null,2,null,2,null,null,null,0,0,null,0,null,null,null,null,null,null,56,null,56,null,15,null,null,56,null,null,48,13,null,null,null,null,null,8,null,null,null,null,28,null,28,null,null,26,null,22,22,null,null,null,2,null,null,null,null,2,2,2,null,null,null,null,null,24,24,24,null,24,24,24,null,24,24,null,null,null,null,null,24,null,null,24,null,null,null,0,null,null,null,null]},{"name":"lib/emailgator_web/schema/resolvers/user.ex","source":"defmodule EmailgatorWeb.Schema.Resolvers.User do\n  def me(_parent, _args, %{context: %{current_user: user}}) when not is_nil(user) do\n    {:ok, user}\n  end\n\n  def me(_parent, _args, _context) do\n    {:error, \"Not authenticated\"}\n  end\nend","coverage":[null,2,null,null,null,4,null,null,null]},{"name":"lib/emailgator_web/schema/context.ex","source":"defmodule EmailgatorWeb.Schema.Context do\n  @behaviour Plug\n\n  import Plug.Conn\n  alias Emailgator.Accounts\n\n  def init(opts), do: opts\n\n  def call(conn, _opts) do\n    user = get_session_user(conn)\n    Absinthe.Plug.put_options(conn, context: %{current_user: user})\n  end\n\n  defp get_session_user(conn) do\n    case get_session(conn, :user_id) do\n      nil -> nil\n      user_id -> Accounts.get_user(user_id)\n    end\n  end\nend","coverage":[null,null,null,null,null,null,1,null,null,9,9,null,null,null,9,6,3,null,null,null]},{"name":"lib/emailgator/jobs/poll_inbox.ex","source":"defmodule Emailgator.Jobs.PollInbox do\n  @moduledoc \"\"\"\n  Polls a Gmail account for new messages.\n  \"\"\"\n  use Oban.Worker, queue: :poll, max_attempts: 3\n  alias Emailgator.{Accounts, Gmail, Jobs.ImportEmail}\n\n  require Logger\n\n  @impl Oban.Worker\n  def perform(%Oban.Job{args: %{\"account_id\" => account_id}}) do\n    Logger.info(\"PollInbox: Starting poll for account #{account_id}\")\n\n    case Accounts.get_account(account_id) do\n      nil ->\n        Logger.error(\"PollInbox: Account #{account_id} not found\")\n        {:cancel, \"Account not found\"}\n\n      account ->\n        Logger.info(\n          \"PollInbox: Found account #{account.id} (email: #{account.email}), last_history_id: #{inspect(account.last_history_id)}\"\n        )\n\n        case Gmail.list_new_message_ids(account) do\n          {:ok, message_ids, new_history_id} ->\n            Logger.info(\n              \"PollInbox: Gmail API returned #{length(message_ids)} new message(s), new_history_id: #{inspect(new_history_id)}\"\n            )\n\n            if Enum.empty?(message_ids) do\n              Logger.info(\"PollInbox: No new messages found\")\n            else\n              Logger.info(\"PollInbox: Queuing import jobs for #{length(message_ids)} message(s)\")\n            end\n\n            # Update history_id (always update, even if it's nil, to track the current state)\n            case Accounts.update_account(account, %{last_history_id: new_history_id}) do\n              {:ok, _updated_account} ->\n                Logger.info(\n                  \"PollInbox: Updated account history_id from #{inspect(account.last_history_id)} to #{inspect(new_history_id)}\"\n                )\n\n                # Verify the update persisted\n                reloaded_account = Accounts.get_account(account_id)\n\n                Logger.info(\n                  \"PollInbox: Verified account.last_history_id is now: #{inspect(reloaded_account.last_history_id)}\"\n                )\n\n              {:error, reason} ->\n                Logger.error(\"PollInbox: Failed to update history_id: #{inspect(reason)}\")\n            end\n\n            # Queue import jobs for each message\n            Enum.each(message_ids, fn message_id ->\n              Logger.debug(\"PollInbox: Queuing ImportEmail job for message_id: #{message_id}\")\n\n              case %{account_id: account_id, message_id: message_id}\n                   |> ImportEmail.new()\n                   |> Oban.insert() do\n                {:ok, job} ->\n                  Logger.debug(\n                    \"PollInbox: Successfully queued ImportEmail job #{job.id} for message_id: #{message_id}\"\n                  )\n\n                {:error, reason} ->\n                  Logger.error(\n                    \"PollInbox: Failed to queue ImportEmail job for message_id #{message_id}: #{inspect(reason)}\"\n                  )\n              end\n            end)\n\n            Logger.info(\n              \"PollInbox: Completed poll for account #{account_id}, found #{length(message_ids)} new message(s)\"\n            )\n\n            :ok\n\n          {:error, reason} ->\n            Logger.error(\n              \"PollInbox: Gmail API error for account #{account_id}: #{inspect(reason)}\"\n            )\n\n            # Handle rate limits with exponential backoff\n            if String.contains?(inspect(reason), \"429\") do\n              Logger.warning(\"PollInbox: Rate limited, snoozing for 5 minutes\")\n              {:snooze, 300}\n            else\n              {:error, reason}\n            end\n        end\n    end\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,12,null,12,null,1,null,null,null,11,0,null,null,11,null,9,0,null,null,9,2,null,7,null,null,null,9,null,9,0,null,null,null,9,null,9,0,null,null,null,0,null,null,null,9,10,null,10,null,null,null,10,0,null,null,null,0,0,null,null,null,null,9,0,null,null,null,null,null,2,2,null,null,null,2,1,null,null,null,null,null,null,null,null]},{"name":"lib/emailgator/jobs/archive_email.ex","source":"defmodule Emailgator.Jobs.ArchiveEmail do\n  @moduledoc \"\"\"\n  Archives an email in Gmail after it's been imported.\n  \"\"\"\n  use Oban.Worker, queue: :archive, max_attempts: 3\n  alias Emailgator.{Accounts, Gmail, Emails}\n\n  @impl Oban.Worker\n  def perform(%Oban.Job{args: %{\"account_id\" => account_id, \"message_id\" => message_id}}) do\n    account = Accounts.get_account(account_id)\n\n    if is_nil(account) do\n      {:cancel, \"Account not found\"}\n    else\n      case Gmail.archive_message(account_id, message_id) do\n        {:ok, :archived} ->\n          # Update email record\n          case Emails.get_email_by_gmail_id(account_id, message_id) do\n            nil -> :ok\n            email -> Emails.update_email(email, %{archived_at: DateTime.utc_now()})\n          end\n\n          :ok\n\n        {:error, reason} ->\n          if String.contains?(inspect(reason), \"429\") do\n            {:snooze, 300}\n          else\n            {:error, reason}\n          end\n      end\n    end\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,9,null,9,null,null,7,null,null,5,2,3,null,null,null,null,null,2,null,null,null,null,null,null,null,null]},{"name":"lib/emailgator_web/controllers/gmail_controller.ex","source":"defmodule EmailgatorWeb.GmailController do\n  @moduledoc \"\"\"\n  Controller for connecting Gmail accounts (separate OAuth flow with Gmail scopes).\n  \"\"\"\n  use EmailgatorWeb, :controller\n  alias Emailgator.Accounts\n  alias Assent.Strategy.Google\n\n  def connect(conn, _params) do\n    user_id = get_session(conn, :user_id)\n\n    if is_nil(user_id) do\n      conn\n      |> put_status(:unauthorized)\n      |> json(%{error: \"Not authenticated\"})\n    else\n      base_url = base_url(conn)\n      redirect_uri = \"#{base_url}/gmail/callback\"\n      config = build_gmail_config(redirect_uri)\n\n      require Logger\n      Logger.info(\"๐ Gmail OAuth Request - redirect_uri: #{redirect_uri}\")\n\n      case Google.authorize_url(config) do\n        {:ok, %{url: url, session_params: session_params}} when is_list(session_params) ->\n          # Convert keyword list to map before storing (Assent expects maps)\n          session_map = Enum.into(session_params, %{})\n\n          Logger.info(\n            \"๐ Gmail - Storing session_params (converted to map): #{inspect(session_map)}\"\n          )\n\n          conn\n          |> put_session(:gmail_connect_user_id, user_id)\n          |> put_session(:gmail_session_params, session_map)\n          |> put_session(:gmail_redirect_uri, redirect_uri)\n          |> redirect(external: url)\n\n        {:ok, %{url: url, session_params: session_params}} when is_map(session_params) ->\n          # Already a map, store directly\n          Logger.info(\n            \"๐ Gmail - Storing session_params (already map): #{inspect(session_params)}\"\n          )\n\n          conn\n          |> put_session(:gmail_connect_user_id, user_id)\n          |> put_session(:gmail_session_params, session_params)\n          |> put_session(:gmail_redirect_uri, redirect_uri)\n          |> redirect(external: url)\n\n        {:ok, %{url: url}} ->\n          # If session_params not returned, Assent might handle state internally\n          Logger.info(\"โ๏ธ  Gmail - No session_params returned from authorize_url\")\n\n          conn\n          |> put_session(:gmail_connect_user_id, user_id)\n          |> put_session(:gmail_redirect_uri, redirect_uri)\n          |> redirect(external: url)\n\n        {:error, error} ->\n          conn\n          |> put_status(:internal_server_error)\n          |> json(%{error: \"Failed to initiate Gmail OAuth: #{inspect(error)}\"})\n      end\n    end\n  end\n\n  def callback(conn, %{\"code\" => _code} = params) do\n    require Logger\n    user_id = get_session(conn, :gmail_connect_user_id)\n\n    if is_nil(user_id) do\n      conn\n      |> put_status(:unauthorized)\n      |> json(%{error: \"Session expired\"})\n    else\n      # Use the EXACT redirect_uri from the initial request (stored in session)\n      redirect_uri = get_session(conn, :gmail_redirect_uri) || \"#{base_url(conn)}/gmail/callback\"\n\n      Logger.info(\n        \"๐ Gmail Callback - redirect_uri from session: #{inspect(get_session(conn, :gmail_redirect_uri))}\"\n      )\n\n      Logger.info(\"๐ Gmail Callback - redirect_uri being used: #{redirect_uri}\")\n\n      config = build_gmail_config(redirect_uri)\n\n      # Retrieve session_params from session\n      session_params = get_session(conn, :gmail_session_params)\n\n      Logger.info(\"๐ Gmail - Retrieved session_params from session: #{inspect(session_params)}\")\n      Logger.info(\"๐ Gmail - Callback params: #{inspect(params)}\")\n      Logger.info(\"๐ Gmail - State from URL: #{inspect(params[\"state\"])}\")\n\n      # Convert session_params to map format (Assent expects a map, not keyword list)\n      # ALWAYS ensure we have at least the state parameter for Assent\n      final_session_params =\n        cond do\n          is_map(session_params) && map_size(session_params) > 0 ->\n            Logger.info(\n              \"โ Gmail - Using session_params map from session: #{inspect(session_params)}\"\n            )\n\n            session_params\n\n          is_list(session_params) && length(session_params) > 0 ->\n            # Convert keyword list to map\n            map = Enum.into(session_params, %{})\n            Logger.info(\"โ Gmail - Converted session_params keyword list to map: #{inspect(map)}\")\n            map\n\n          params[\"state\"] != nil ->\n            # Fallback: use state from URL params - create as map\n            state = params[\"state\"]\n\n            Logger.warning(\n              \"โ๏ธ  Gmail - No session_params in session, using state from URL params: #{state}\"\n            )\n\n            Logger.warning(\"โ๏ธ  This may indicate session wasn't persisted across redirect\")\n            %{state: state}\n\n          true ->\n            Logger.error(\"โ Gmail - No session_params and no state in params - cannot proceed\")\n            %{}\n        end\n\n      # CRITICAL: Assent REQUIRES session_params with at least 'state' key\n      # Always merge session_params into config, using state from URL if session was lost\n      callback_config =\n        if map_size(final_session_params) > 0 do\n          Logger.info(\n            \"โ Gmail - Merging session_params into config: #{inspect(final_session_params)}\"\n          )\n\n          Keyword.merge(config, session_params: final_session_params)\n        else\n          # Last resort: extract state from params and use it\n          state_from_params = params[\"state\"]\n\n          if state_from_params do\n            Logger.warning(\n              \"โ๏ธ  Gmail - Session lost, using state from callback URL: #{state_from_params}\"\n            )\n\n            Keyword.merge(config, session_params: %{state: state_from_params})\n          else\n            Logger.error(\"โ Gmail - No state available - OAuth will fail!\")\n            Logger.error(\"โ Config without session_params: #{inspect(config)}\")\n            config\n          end\n        end\n\n      Logger.info(\n        \"๐ Gmail Callback config has session_params: #{Keyword.has_key?(callback_config, :session_params)}\"\n      )\n\n      Logger.info(\n        \"๐ Gmail Callback config session_params value: #{inspect(Keyword.get(callback_config, :session_params))}\"\n      )\n\n      case Google.callback(callback_config, params) do\n        {:ok, %{user: user_params, token: token}} ->\n          # Extract tokens from token map (Assent returns as map with string keys)\n          access_token = Map.get(token, \"access_token\") || Map.get(token, :access_token)\n          refresh_token = Map.get(token, \"refresh_token\") || Map.get(token, :refresh_token)\n\n          if is_nil(access_token) or is_nil(refresh_token) do\n            conn\n            |> delete_session(:gmail_connect_user_id)\n            |> delete_session(:gmail_session_params)\n            |> delete_session(:gmail_redirect_uri)\n            |> put_status(:internal_server_error)\n            |> json(%{error: \"OAuth callback missing tokens\"})\n          else\n            # Get user's email from user_params\n            email = user_params[\"email\"] || user_params[\"email_address\"]\n            expires_at = calculate_expires_at(token)\n\n            # Create or update Gmail account\n            case Accounts.get_account_by_email(user_id, email) do\n              nil ->\n                Accounts.create_account(%{\n                  user_id: user_id,\n                  email: email,\n                  access_token: access_token,\n                  refresh_token: refresh_token,\n                  expires_at: expires_at\n                })\n\n              existing_account ->\n                Accounts.update_account(existing_account, %{\n                  access_token: access_token,\n                  refresh_token: refresh_token,\n                  expires_at: expires_at\n                })\n            end\n            |> case do\n              {:ok, _account} ->\n                frontend_url = System.get_env(\"FRONTEND_URL\") || \"http://localhost:3000\"\n                redirect_url = \"#{frontend_url}?gmail=connected\"\n\n                conn\n                |> delete_session(:gmail_connect_user_id)\n                |> delete_session(:gmail_session_params)\n                |> delete_session(:gmail_redirect_uri)\n                |> redirect(external: redirect_url)\n\n              {:error, changeset} ->\n                conn\n                |> delete_session(:gmail_connect_user_id)\n                |> delete_session(:gmail_session_params)\n                |> delete_session(:gmail_redirect_uri)\n                |> put_status(:unprocessable_entity)\n                |> json(%{error: \"Failed to connect account: #{inspect(changeset.errors)}\"})\n            end\n          end\n\n        {:error, error} ->\n          conn\n          |> delete_session(:gmail_connect_user_id)\n          |> delete_session(:gmail_session_params)\n          |> delete_session(:gmail_redirect_uri)\n          |> put_status(:internal_server_error)\n          |> json(%{error: \"OAuth callback failed: #{inspect(error)}\"})\n      end\n    end\n  end\n\n  def callback(conn, %{\"error\" => error, \"error_description\" => description}) do\n    conn\n    |> delete_session(:gmail_connect_user_id)\n    |> delete_session(:gmail_session_params)\n    |> delete_session(:gmail_redirect_uri)\n    |> put_status(:bad_request)\n    |> json(%{error: error, description: description})\n  end\n\n  def callback(conn, _params) do\n    conn\n    |> delete_session(:gmail_connect_user_id)\n    |> delete_session(:gmail_session_params)\n    |> delete_session(:gmail_redirect_uri)\n    |> put_status(:bad_request)\n    |> json(%{error: \"Missing code parameter\"})\n  end\n\n  defp base_url(conn) do\n    scheme = if conn.scheme == :https, do: \"https\", else: \"http\"\n    port_str = if conn.port == 80 or conn.port == 443, do: \"\", else: \":#{conn.port}\"\n    \"#{scheme}://#{conn.host}#{port_str}\"\n  end\n\n  defp build_gmail_config(redirect_uri) do\n    assent_config = Application.get_env(:emailgator_api, :assent, [])\n    provider_config = Keyword.get(assent_config, :providers, []) |> Keyword.get(:google, [])\n\n    [\n      client_id: Keyword.get(provider_config, :client_id),\n      client_secret: Keyword.get(provider_config, :client_secret),\n      redirect_uri: redirect_uri,\n      authorization_params: [\n        access_type: \"offline\",\n        prompt: \"consent\",\n        scope:\n          \"email profile https://www.googleapis.com/auth/gmail.readonly https://www.googleapis.com/auth/gmail.modify\"\n      ]\n    ]\n  end\n\n  defp calculate_expires_at(token) do\n    # Get expires_in from token, default to 3600 seconds (1 hour)\n    expires_in =\n      Map.get(token, \"expires_in\") ||\n        Map.get(token, :expires_in) ||\n        3600\n\n    DateTime.add(DateTime.utc_now(), expires_in, :second)\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,7,null,7,null,null,1,null,6,6,6,null,null,6,null,6,null,null,0,null,0,null,null,null,null,null,null,null,0,null,null,null,6,null,null,null,null,null,null,null,6,null,null,null,0,null,null,null,null,0,null,null,null,null,0,null,null,null,null,null,null,18,null,18,null,null,1,null,null,17,null,17,null,null,null,17,null,17,null,null,17,null,17,17,17,null,null,null,17,null,17,10,null,null,null,10,null,7,null,1,1,1,null,6,null,4,null,4,4,null,null,4,4,null,2,2,2,null,null,null,null,17,null,15,null,null,null,15,null,null,2,null,2,0,0,null,null,0,null,2,2,2,null,null,null,17,0,null,null,17,null,null,null,17,null,null,0,0,null,0,null,null,null,null,null,0,null,null,0,0,null,null,null,null,0,null,null,null,null,null,null,null,null,0,null,null,null,null,null,0,null,0,0,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,17,null,null,null,null,null,null,null,null,null,null,2,null,null,null,null,null,null,null,null,2,null,null,null,8,8,8,null,null,null,23,23,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,null,null,0,null,null]},{"name":"lib/emailgator_web/schema.ex","source":"defmodule EmailgatorWeb.Schema do\n  use Absinthe.Schema\n\n  import_types(EmailgatorWeb.Schema.Types)\n\n  query do\n    field :me, :user do\n      resolve(&EmailgatorWeb.Schema.Resolvers.User.me/3)\n    end\n\n    field :categories, list_of(:category) do\n      resolve(&EmailgatorWeb.Schema.Resolvers.Category.list/3)\n    end\n\n    field :category, :category do\n      arg(:id, non_null(:id))\n      resolve(&EmailgatorWeb.Schema.Resolvers.Category.get/3)\n    end\n\n    field :accounts, list_of(:account) do\n      resolve(&EmailgatorWeb.Schema.Resolvers.Account.list/3)\n    end\n\n    field :connect_gmail_url, :string do\n      resolve(&EmailgatorWeb.Schema.Resolvers.Account.get_connect_url/3)\n    end\n\n    field :category_emails, list_of(:email) do\n      arg(:category_id, non_null(:id))\n      resolve(&EmailgatorWeb.Schema.Resolvers.Email.list_by_category/3)\n    end\n\n    field :polling_status, :boolean do\n      arg(:account_id, :id)\n      resolve(&EmailgatorWeb.Schema.Resolvers.Account.polling_status/3)\n    end\n\n    field :email, :email do\n      arg(:id, non_null(:id))\n      resolve(&EmailgatorWeb.Schema.Resolvers.Email.get_email/3)\n    end\n  end\n\n  mutation do\n    field :create_category, :category do\n      arg(:name, non_null(:string))\n      arg(:description, :string)\n\n      resolve(&EmailgatorWeb.Schema.Resolvers.Category.create/3)\n    end\n\n    field :update_category, :category do\n      arg(:id, non_null(:id))\n      arg(:name, :string)\n      arg(:description, :string)\n\n      resolve(&EmailgatorWeb.Schema.Resolvers.Category.update/3)\n    end\n\n    field :delete_category, :category do\n      arg(:id, non_null(:id))\n      resolve(&EmailgatorWeb.Schema.Resolvers.Category.delete/3)\n    end\n\n    field :disconnect_account, :account do\n      arg(:id, non_null(:id))\n      resolve(&EmailgatorWeb.Schema.Resolvers.Account.disconnect/3)\n    end\n\n    field :delete_emails, list_of(:id) do\n      arg(:email_ids, non_null(list_of(non_null(:id))))\n      resolve(&EmailgatorWeb.Schema.Resolvers.Email.bulk_delete/3)\n    end\n\n    field :unsubscribe_emails, list_of(:unsubscribe_result) do\n      arg(:email_ids, non_null(list_of(non_null(:id))))\n      resolve(&EmailgatorWeb.Schema.Resolvers.Email.bulk_unsubscribe/3)\n    end\n\n    field :trigger_poll, :boolean do\n      arg(:account_id, :id)\n\n      resolve(&EmailgatorWeb.Schema.Resolvers.Account.trigger_poll/3)\n    end\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"lib/emailgator/accounts/user.ex","source":"defmodule Emailgator.Accounts.User do\n  use Ecto.Schema\n  import Ecto.Changeset\n  alias Emailgator.Accounts.Account\n\n  @primary_key {:id, :binary_id, autogenerate: true}\n  @foreign_key_type :binary_id\n\n  schema \"users\" do\n    field(:email, :string)\n    field(:name, :string)\n\n    has_many(:accounts, Account)\n    has_many(:categories, Emailgator.Categories.Category)\n\n    timestamps()\n  end\n\n  @doc false\n  def changeset(user, attrs) do\n    user\n    |> cast(attrs, [:email, :name])\n    |> validate_required([:email])\n    |> validate_format(:email, ~r/^[^\\s]+@[^\\s]+$/, message: \"must be a valid email\")\n    |> unique_constraint(:email)\n  end\nend","coverage":[null,null,null,null,null,null,null,null,2709,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,380,null,null]},{"name":"lib/emailgator_web/schema/resolvers/account.ex","source":"defmodule EmailgatorWeb.Schema.Resolvers.Account do\n  alias Emailgator.{Accounts, Jobs.PollInbox}\n\n  def list(_parent, _args, %{context: %{current_user: %{id: user_id}}}) do\n    {:ok, Accounts.list_user_accounts(user_id)}\n  end\n\n  def list(_parent, _args, _context) do\n    {:error, \"Not authenticated\"}\n  end\n\n  def get_connect_url(_parent, _args, %{context: %{current_user: user}}) when not is_nil(user) do\n    # Return the URL to redirect to for Gmail OAuth\n    # Frontend will handle the redirect\n    endpoint_config = Application.get_env(:emailgator_api, EmailgatorWeb.Endpoint, [])\n    host = Keyword.get(endpoint_config, :url, []) |> Keyword.get(:host, \"localhost\")\n    port = 4000\n    scheme = \"http\"\n\n    {:ok, \"#{scheme}://#{host}:#{port}/gmail/connect\"}\n  end\n\n  def get_connect_url(_parent, _args, _context) do\n    {:error, \"Not authenticated\"}\n  end\n\n  def disconnect(_parent, %{id: id}, %{context: %{current_user: user}}) when not is_nil(user) do\n    case Accounts.get_account(id) do\n      nil -> {:error, \"Account not found\"}\n      account -> Accounts.delete_account(account)\n    end\n  end\n\n  def disconnect(_parent, _args, _context) do\n    {:error, \"Not authenticated\"}\n  end\n\n  def trigger_poll(_parent, args, %{context: %{current_user: %{id: user_id}}}) do\n    case Map.get(args, :account_id) do\n      nil ->\n        # Poll all user's active accounts\n        accounts = Accounts.list_user_accounts(user_id)\n\n        accounts\n        |> Enum.filter(fn account -> not is_nil(account.refresh_token) end)\n        |> Enum.each(fn account ->\n          %{account_id: account.id}\n          |> PollInbox.new()\n          |> Oban.insert()\n        end)\n\n        {:ok, true}\n\n      account_id ->\n        # Poll specific account if it belongs to user\n        case Accounts.get_account(account_id) do\n          nil ->\n            {:error, \"Account not found\"}\n\n          account ->\n            if account.user_id == user_id do\n              %{account_id: account_id}\n              |> PollInbox.new()\n              |> Oban.insert()\n\n              {:ok, true}\n            else\n              {:error, \"Account does not belong to user\"}\n            end\n        end\n    end\n  end\n\n  def trigger_poll(_parent, _args, _context) do\n    {:error, \"Not authenticated\"}\n  end\n\n  def polling_status(_parent, args, %{context: %{current_user: %{id: user_id}}}) do\n    import Ecto.Query\n    alias Emailgator.Repo\n\n    account_id = Map.get(args, :account_id)\n\n    # Build query based on whether account_id is provided\n    query =\n      if account_id do\n        # Verify account belongs to user\n        case Accounts.get_account(account_id) do\n          nil ->\n            {:error, \"Account not found\"}\n\n          account ->\n            if account.user_id == user_id do\n              from(j in Oban.Job,\n                where:\n                  j.queue == \"poll\" and\n                    j.state in [\"available\", \"executing\", \"scheduled\"] and\n                    fragment(\"?->>'account_id'\", j.args) == ^to_string(account_id)\n              )\n            else\n              {:error, \"Account does not belong to user\"}\n            end\n        end\n      else\n        # Check all user's accounts\n        account_ids =\n          Accounts.list_user_accounts(user_id)\n          |> Enum.map(& &1.id)\n          |> Enum.map(&to_string/1)\n\n        if Enum.empty?(account_ids) do\n          {:ok, false}\n        else\n          # Check if any executing poll jobs have account_id in args matching user's accounts\n          # Use a simpler approach: check each account_id and see if any match\n          result =\n            account_ids\n            |> Enum.any?(fn account_id_str ->\n              query =\n                from(j in Oban.Job,\n                  where:\n                    j.queue == \"poll\" and\n                      j.state in [\"available\", \"executing\", \"scheduled\"] and\n                      fragment(\"?->>'account_id'\", j.args) == ^account_id_str\n                )\n\n              Repo.exists?(query)\n            end)\n\n          {:ok, result}\n        end\n      end\n\n    # Handle the result - either an error tuple, ok tuple, or a query to execute\n    case query do\n      {:error, _} = error ->\n        error\n\n      {:ok, _} = result ->\n        # Already handled (empty account_ids case or multiple accounts check)\n        result\n\n      _query ->\n        # Execute query and return count\n        count = Repo.aggregate(query, :count, :id)\n        {:ok, count > 0}\n    end\n  end\n\n  def polling_status(_parent, _args, _context) do\n    {:error, \"Not authenticated\"}\n  end\nend","coverage":[null,null,null,1,null,null,null,1,null,null,null,null,null,null,2,2,2,2,null,2,null,null,1,null,null,null,null,5,2,3,null,null,null,1,null,null,null,null,7,null,null,4,null,null,7,4,7,null,7,null,null,null,null,null,null,3,1,null,null,null,2,null,null,1,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,12,null,null,12,2,null,9,2,null,null,null,7,5,null,null,null,5,null,null,null,null,null,null,null,3,null,2,2,null,3,null,null,null,null,2,null,null,2,null,null,null,null,null,null,null,2,null,null,null,null,null,null,null,12,null,4,null,null,null,3,null,null,null,5,null,null,null,null,1,null,null,null]},{"name":"lib/emailgator_web/controllers/auth_controller.ex","source":"defmodule EmailgatorWeb.AuthController do\n  use EmailgatorWeb, :controller\n  alias Emailgator.Accounts\n  alias Assent.Strategy.Google\n\n  def request(conn, _params) do\n    # Use configured redirect_uri or construct from connection\n    # IMPORTANT: Must match exactly what's registered in Google Console\n    redirect_uri = get_redirect_uri(conn)\n    config = build_config(redirect_uri)\n\n    require Logger\n    Logger.info(\"๐ OAuth Request - redirect_uri: #{redirect_uri}\")\n    Logger.info(\"๐ OAuth Request - base_url from conn: #{base_url(conn)}\")\n\n    Logger.info(\n      \"๐ OAuth Request - GOOGLE_OAUTH_REDIRECT_URL env: #{inspect(System.get_env(\"GOOGLE_OAUTH_REDIRECT_URL\"))}\"\n    )\n\n    case Google.authorize_url(config) do\n      {:ok, %{url: url, session_params: session_params}} when is_list(session_params) ->\n        # Convert keyword list to map before storing (Assent expects maps)\n        session_map = Enum.into(session_params, %{})\n        Logger.info(\"๐ Storing session_params (converted to map): #{inspect(session_map)}\")\n\n        conn\n        |> put_session(:oauth_session_params, session_map)\n        # Store redirect_uri for callback\n        |> put_session(:oauth_redirect_uri, redirect_uri)\n        |> redirect(external: url)\n\n      {:ok, %{url: url, session_params: session_params}} when is_map(session_params) ->\n        # Already a map, store directly\n        Logger.info(\"๐ Storing session_params (already map): #{inspect(session_params)}\")\n\n        conn\n        |> put_session(:oauth_session_params, session_params)\n        # Store redirect_uri for callback\n        |> put_session(:oauth_redirect_uri, redirect_uri)\n        |> redirect(external: url)\n\n      {:ok, %{url: url}} ->\n        # If session_params not returned, Assent might handle state internally\n        Logger.info(\"โ๏ธ  No session_params returned from authorize_url\")\n\n        conn\n        # Store redirect_uri for callback\n        |> put_session(:oauth_redirect_uri, redirect_uri)\n        |> redirect(external: url)\n\n      {:error, error} ->\n        conn\n        |> put_status(:internal_server_error)\n        |> json(%{error: \"Failed to initiate OAuth flow: #{inspect(error)}\"})\n    end\n  end\n\n  def callback(conn, %{\"code\" => _code} = params) do\n    # Check if authorization code might be reused (single-use only!)\n    require Logger\n\n    # Use the EXACT redirect_uri from the initial request (stored in session)\n    # This ensures it matches what Google has in its token exchange\n    redirect_uri = get_session(conn, :oauth_redirect_uri) || get_redirect_uri(conn)\n\n    # Warn if session is missing - might indicate code reuse\n    if get_session(conn, :oauth_redirect_uri) == nil do\n      Logger.warning(\n        \"โ๏ธ  No session found - this might be a reused authorization code. Authorization codes are single-use and expire quickly.\"\n      )\n\n      Logger.warning(\n        \"โ๏ธ  If you're seeing 'invalid_grant', you need to start a fresh OAuth flow from the beginning.\"\n      )\n    end\n\n    require Logger\n\n    Logger.info(\n      \"๐ OAuth Callback - redirect_uri from session: #{inspect(get_session(conn, :oauth_redirect_uri))}\"\n    )\n\n    Logger.info(\"๐ OAuth Callback - redirect_uri being used: #{redirect_uri}\")\n    Logger.info(\"๐ OAuth Callback - base_url from conn: #{base_url(conn)}\")\n\n    Logger.info(\n      \"๐ OAuth Callback - GOOGLE_OAUTH_REDIRECT_URL env: #{inspect(System.get_env(\"GOOGLE_OAUTH_REDIRECT_URL\"))}\"\n    )\n\n    config = build_config(redirect_uri)\n\n    # Retrieve session_params from session\n    session_params = get_session(conn, :oauth_session_params)\n\n    require Logger\n    Logger.info(\"๐ Retrieved session_params from session: #{inspect(session_params)}\")\n    Logger.info(\"๐ OAuth callback params: #{inspect(params)}\")\n\n    # Convert session_params to map format (Assent expects a map, not keyword list)\n    # Phoenix sessions might store as keyword list, so convert to map\n    final_session_params =\n      cond do\n        is_map(session_params) && map_size(session_params) > 0 ->\n          Logger.info(\"โ Using session_params map from session: #{inspect(session_params)}\")\n          session_params\n\n        is_list(session_params) && length(session_params) > 0 ->\n          # Convert keyword list to map\n          map = Enum.into(session_params, %{})\n          Logger.info(\"โ Converted session_params keyword list to map: #{inspect(map)}\")\n          map\n\n        params[\"state\"] != nil ->\n          # Fallback: use state from URL params - create as map\n          state = params[\"state\"]\n          Logger.warning(\"โ๏ธ  No session_params found, using state from URL params: #{state}\")\n          %{state: state}\n\n        true ->\n          Logger.error(\"โ No session_params and no state in params - OAuth flow may fail\")\n          %{}\n      end\n\n    # Merge session_params into config (only if not empty)\n    callback_config =\n      if map_size(final_session_params) > 0 do\n        Keyword.merge(config, session_params: final_session_params)\n      else\n        config\n      end\n\n    # Debug: Log the complete callback config being sent to Google\n    Logger.info(\n      \"๐ Callback config: client_id = #{inspect(Keyword.get(callback_config, :client_id))}\"\n    )\n\n    Logger.info(\n      \"๐ Callback config: redirect_uri = #{inspect(Keyword.get(callback_config, :redirect_uri))}\"\n    )\n\n    Logger.info(\"๐ Callback config: has session_params = #{map_size(final_session_params) > 0}\")\n\n    case Google.callback(callback_config, params) do\n      {:ok, %{user: user_params}} ->\n        # Clear OAuth session params after successful callback\n        conn = delete_session(conn, :oauth_session_params)\n\n        case Accounts.create_or_update_user(user_params) do\n          {:ok, user} ->\n            frontend_url = System.get_env(\"FRONTEND_URL\") || \"http://localhost:3000\"\n            redirect_url = \"#{frontend_url}?auth=success\"\n\n            conn\n            |> put_session(:user_id, user.id)\n            |> put_session(:user_email, user.email)\n            |> redirect(external: redirect_url)\n\n          {:error, changeset} ->\n            conn\n            |> put_status(:unprocessable_entity)\n            |> json(%{error: \"Failed to create user: #{inspect(changeset.errors)}\"})\n        end\n\n      {:error, error} ->\n        # Clear session params on error\n        conn\n        |> delete_session(:oauth_session_params)\n        |> put_status(:internal_server_error)\n        |> json(%{error: \"OAuth callback failed: #{inspect(error)}\"})\n    end\n  end\n\n  def callback(conn, %{\"error\" => error, \"error_description\" => description}) do\n    conn\n    |> put_status(:bad_request)\n    |> json(%{error: error, description: description})\n  end\n\n  def callback(conn, _params) do\n    conn\n    |> put_status(:bad_request)\n    |> json(%{error: \"Missing code parameter\"})\n  end\n\n  def delete(conn, _params) do\n    frontend_url = System.get_env(\"FRONTEND_URL\") || \"http://localhost:3000\"\n\n    conn\n    |> clear_session()\n    |> redirect(external: frontend_url)\n  end\n\n  defp base_url(conn) do\n    scheme = if conn.scheme == :https, do: \"https\", else: \"http\"\n    port_str = if conn.port == 80 or conn.port == 443, do: \"\", else: \":#{conn.port}\"\n    \"#{scheme}://#{conn.host}#{port_str}\"\n  end\n\n  defp get_redirect_uri(conn) do\n    # Use configured redirect_uri from env if available, otherwise construct from connection\n    case System.get_env(\"GOOGLE_OAUTH_REDIRECT_URL\") do\n      nil ->\n        base_url = base_url(conn)\n        \"#{base_url}/auth/google/callback\"\n\n      configured_uri ->\n        configured_uri\n    end\n  end\n\n  defp build_config(redirect_uri) do\n    assent_config = Application.get_env(:emailgator_api, :assent, [])\n    provider_config = Keyword.get(assent_config, :providers, []) |> Keyword.get(:google, [])\n\n    # Debug: Log the client_id being used\n    client_id = Keyword.get(provider_config, :client_id)\n    require Logger\n    Logger.info(\"๐ OAuth Config Debug: client_id = #{inspect(client_id)}\")\n    Logger.info(\"๐ OAuth Config Debug: redirect_uri = #{redirect_uri}\")\n\n    Logger.info(\n      \"๐ OAuth Config Debug: ENV GOOGLE_CLIENT_ID = #{inspect(System.get_env(\"GOOGLE_CLIENT_ID\"))}\"\n    )\n\n    [\n      client_id: client_id,\n      client_secret: Keyword.get(provider_config, :client_secret),\n      redirect_uri: redirect_uri,\n      authorization_params: [\n        access_type: \"offline\",\n        scope: \"email profile\"\n      ]\n    ]\n  end\nend","coverage":[null,null,null,null,null,null,null,null,4,4,null,null,4,4,null,4,null,null,null,4,null,null,0,0,null,null,null,null,null,0,null,null,null,4,null,null,null,null,null,4,null,null,null,0,null,null,null,null,0,null,null,null,null,0,null,null,null,null,null,null,null,null,null,4,null,null,4,1,null,null,null,1,null,null,null,null,null,null,4,null,null,null,4,4,null,4,null,null,null,4,null,null,4,null,null,4,4,null,null,null,4,null,4,1,1,null,3,null,1,1,1,null,2,null,1,1,1,null,1,1,1,null,null,null,4,null,3,null,1,null,null,null,4,null,null,null,4,null,null,null,4,null,4,null,null,0,null,0,null,0,0,null,null,0,0,0,null,null,null,null,0,null,null,null,null,null,null,null,4,null,null,null,null,null,null,1,null,null,null,null,null,1,null,null,null,2,null,null,null,2,null,null,null,1,1,1,null,null,null,null,5,null,1,1,null,null,4,null,null,null,null,8,8,null,null,8,null,8,8,null,8,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"deps/absinthe/lib/absinthe/phase/schema/compile.ex","source":"defmodule Absinthe.Phase.Schema.Compile do\n  @moduledoc false\n\n  alias Absinthe.Blueprint.Schema\n\n  def run(blueprint, opts) do\n    module_name = Module.concat(opts[:schema], Compiled)\n\n    %{schema_definitions: [schema]} = blueprint\n\n    prototype_schema = Keyword.fetch!(opts, :prototype_schema)\n\n    type_ast = build_types(schema.type_artifacts, prototype_schema)\n\n    directive_ast = build_directives(schema.directive_artifacts)\n\n    type_list =\n      Map.new(schema.type_definitions, fn type_def ->\n        {type_def.identifier, type_def.name}\n      end)\n\n    type_list =\n      case prototype_schema do\n        Absinthe.Schema.Prototype ->\n          type_list\n\n        prototype_schema ->\n          Map.merge(type_list, prototype_schema.__absinthe_types__())\n      end\n\n    referenced_types =\n      for type_def <- schema.type_definitions,\n          type_def.__private__[:__absinthe_referenced__],\n          into: %{},\n          do: {type_def.identifier, type_def.name}\n\n    referenced_types =\n      case prototype_schema do\n        Absinthe.Schema.Prototype ->\n          referenced_types\n\n        prototype_schema ->\n          Map.merge(referenced_types, prototype_schema.__absinthe_types__(:referenced))\n      end\n\n    directive_list =\n      Map.new(schema.directive_artifacts, fn type_def ->\n        {type_def.identifier, type_def.name}\n      end)\n\n    metadata = build_metadata(schema)\n\n    implementors = build_implementors(schema)\n\n    body =\n      quote do\n        @moduledoc false\n\n        unquote_splicing(type_ast)\n        unquote_splicing(directive_ast)\n\n        def __absinthe_types__() do\n          __absinthe_types__(:referenced)\n        end\n\n        def __absinthe_types__(:referenced) do\n          unquote(Macro.escape(referenced_types))\n        end\n\n        def __absinthe_types__(:all) do\n          unquote(Macro.escape(type_list))\n        end\n\n        def __absinthe_directives__() do\n          unquote(Macro.escape(directive_list))\n        end\n\n        def __absinthe_interface_implementors__() do\n          unquote(Macro.escape(implementors))\n        end\n\n        def __absinthe_prototype_schema__() do\n          unquote(Macro.escape(prototype_schema))\n        end\n\n        def __absinthe_schema_declaration__() do\n          unquote(Macro.escape(schema.schema_declaration))\n        end\n\n        unquote_splicing(metadata)\n      end\n\n    Module.create(module_name, body, Macro.Env.location(__ENV__))\n\n    {:ok, blueprint}\n  end\n\n  def build_metadata(schema) do\n    for type <- schema.type_definitions do\n      quote do\n        def __absinthe_reference__(unquote(type.identifier)) do\n          unquote(Macro.escape(type.__reference__))\n        end\n      end\n    end\n  end\n\n  def build_types(types, prototype_schema) do\n    for type <- types do\n      if !type.definition,\n        do:\n          raise(\"\"\"\n          No definition set!\n          #{inspect(type)}\n          \"\"\")\n\n      ast = Macro.escape(type, unquote: true)\n\n      quote do\n        def __absinthe_type__(unquote(type.identifier)) do\n          unquote(ast)\n        end\n\n        def __absinthe_type__(unquote(type.name)) do\n          __absinthe_type__(unquote(type.identifier))\n        end\n      end\n    end\n    |> Enum.concat([\n      if prototype_schema == Absinthe.Schema.Prototype do\n        quote do\n          def __absinthe_type__(_type), do: nil\n        end\n      else\n        quote do\n          def __absinthe_type__(type), do: unquote(prototype_schema).__absinthe_type__(type)\n        end\n      end\n    ])\n  end\n\n  def build_directives(directives) do\n    for type <- directives do\n      ast = Macro.escape(type)\n\n      quote do\n        def __absinthe_directive__(unquote(type.identifier)) do\n          unquote(ast)\n        end\n\n        def __absinthe_directive__(unquote(type.name)) do\n          __absinthe_directive__(unquote(type.identifier))\n        end\n      end\n    end\n    |> Enum.concat([\n      quote do\n        def __absinthe_directive__(_type) do\n          nil\n        end\n      end\n    ])\n  end\n\n  defp build_implementors(schema) do\n    schema.type_definitions\n    |> Enum.filter(&match?(%Schema.InterfaceTypeDefinition{}, &1))\n    |> Map.new(fn iface ->\n      implementors =\n        Schema.InterfaceTypeDefinition.find_implementors(iface, schema.type_definitions)\n\n      {iface.identifier, Enum.sort(implementors)}\n    end)\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"lib/emailgator/llm.ex","source":"defmodule Emailgator.LLM do\n  @moduledoc \"\"\"\n  LLM adapter for OpenAI (GPT-4o-mini).\n  \"\"\"\n  use Tesla\n  alias Emailgator.Categories.Category\n\n  require Logger\n\n  adapter(Tesla.Adapter.Finch, name: Emailgator.Finch)\n\n  plug(Tesla.Middleware.BaseUrl, Application.get_env(:emailgator_api, :openai)[:base_url])\n  plug(Tesla.Middleware.JSON)\n\n  @doc \"\"\"\n  Classify email into a category and generate a summary.\n  Returns {:ok, %{category_id: id, summary: text, unsubscribe_urls: [urls]}}\n  \"\"\"\n  def classify_and_summarize(email_meta, body_text, categories) do\n    Logger.info(\n      \"LLM.classify_and_summarize: Starting classification for email from #{Map.get(email_meta, :from, \"unknown\")}\"\n    )\n\n    categories_json = format_categories(categories)\n    prompt = build_prompt(email_meta, body_text, categories_json)\n\n    case call_openai(prompt) do\n      {:ok, response} ->\n        Logger.info(\"LLM.classify_and_summarize: Received response from OpenAI, parsing...\")\n        result = parse_response(response, categories)\n\n        case result do\n          {:ok, %{category_id: cat_id}} ->\n            Logger.info(\n              \"LLM.classify_and_summarize: Successfully classified into category #{cat_id}\"\n            )\n\n          _ ->\n            Logger.warning(\n              \"LLM.classify_and_summarize: Classification returned error: #{inspect(result)}\"\n            )\n        end\n\n        result\n\n      {:error, reason} ->\n        Logger.error(\"LLM.classify_and_summarize: OpenAI API error: #{inspect(reason)}\")\n        {:error, reason}\n    end\n  end\n\n  # Private helpers\n\n  defp format_categories(categories) do\n    categories\n    |> Enum.map(fn %Category{id: id, name: name, description: desc} ->\n      %{id: id, name: name, description: desc || \"\"}\n    end)\n    |> Jason.encode!()\n  end\n\n  defp build_prompt(email_meta, body_text, categories_json) do\n    subject = Map.get(email_meta, :subject, \"\")\n    from = Map.get(email_meta, :from, \"\")\n\n    \"\"\"\n    You are an email classification assistant. Analyze the following email and classify it into ONE of the provided categories. Also provide a concise summary.\n\n    Categories:\n    #{categories_json}\n\n    Email:\n    Subject: #{subject}\n    From: #{from}\n    Body: #{String.slice(body_text, 0, 4000)}\n\n    Return a valid JSON object with this exact structure:\n    {\n      \"category_id\": \"<uuid-of-category>\",\n      \"summary\": \"<brief summary in 2-3 sentences>\",\n      \"unsubscribe_urls\": [\"<url1>\", \"<url2>\"]\n    }\n\n    If no category matches well, choose the first category. Extract ALL unsubscribe URLs from the email body text and HTML links. Look for patterns like:\n    - Links containing \"unsubscribe\", \"opt-out\", \"opt out\", \"manage preferences\", \"email preferences\", \"berhenti berlangganan\"\n    - mailto: links with subject containing \"unsubscribe\"\n    - URLs in text that clearly indicate unsubscribing\n\n    Return an empty array [] if no unsubscribe URLs are found. Only include actual URLs (http://, https://, or mailto:).\n    \"\"\"\n  end\n\n  defp call_openai(prompt) do\n    api_key = Application.get_env(:emailgator_api, :openai)[:api_key]\n\n    if is_nil(api_key) or api_key == \"\" do\n      Logger.error(\"LLM.call_openai: OpenAI API key is missing\")\n      {:error, \"OpenAI API key not configured\"}\n    else\n      headers = [\n        {\"Authorization\", \"Bearer #{api_key}\"}\n      ]\n\n      # Tesla.Middleware.JSON expects atom keys and will encode to JSON automatically\n      body = %{\n        model: \"gpt-4o-mini\",\n        messages: [\n          %{\n            role: \"system\",\n            content: \"You are a helpful email assistant. Always respond with valid JSON only.\"\n          },\n          %{\n            role: \"user\",\n            content: prompt\n          }\n        ],\n        response_format: %{type: \"json_object\"},\n        temperature: 0.3\n      }\n\n      # Encode body manually to ensure it's JSON\n      body_json = Jason.encode!(body)\n      Logger.debug(\"LLM.call_openai: Request body encoded, length: #{byte_size(body_json)} bytes\")\n\n      Logger.info(\n        \"LLM.call_openai: Making request to OpenAI API (timeout: 60s), model: gpt-4o-mini\"\n      )\n\n      # Use Task with timeout to prevent hanging requests\n      task =\n        Task.async(fn ->\n          try do\n            # Send JSON string directly with proper content-type\n            result =\n              post(\"/chat/completions\", body_json,\n                headers: [{\"Content-Type\", \"application/json\"} | headers]\n              )\n\n            Logger.debug(\"LLM.call_openai: Request completed in Task\")\n            result\n          rescue\n            e ->\n              Logger.error(\"LLM.call_openai: Exception in Task: #{inspect(e)}\")\n              {:error, inspect(e)}\n          catch\n            :exit, reason ->\n              Logger.error(\"LLM.call_openai: Task exited: #{inspect(reason)}\")\n              {:error, inspect(reason)}\n          end\n        end)\n\n      Logger.debug(\"LLM.call_openai: Waiting for Task with 60s timeout...\")\n\n      result =\n        case Task.yield(task, 60_000) || Task.shutdown(task) do\n          {:ok,\n           {:ok,\n            %Tesla.Env{\n              status: 200,\n              body: %{\"choices\" => [%{\"message\" => %{\"content\" => content}} | _]}\n            }}} ->\n            Logger.info(\"LLM.call_openai: Successfully received response from OpenAI\")\n            {:ok, content}\n\n          {:ok, {:ok, %Tesla.Env{status: status, body: body}}} ->\n            # Handle rate limits (429)\n            if status == 429 do\n              Logger.warning(\"LLM.call_openai: Rate limit exceeded, will retry with backoff\")\n              # Return a special error that triggers retry with backoff\n              {:error, {:rate_limit, body}}\n            else\n              Logger.error(\"LLM.call_openai: OpenAI API error #{status}: #{inspect(body)}\")\n              {:error, \"OpenAI API error #{status}: #{inspect(body)}\"}\n            end\n\n          {:ok, {:error, reason}} ->\n            Logger.error(\"LLM.call_openai: Request error: #{inspect(reason)}\")\n            {:error, reason}\n\n          nil ->\n            Logger.error(\"LLM.call_openai: Request timed out after 60 seconds\")\n            {:error, \"Request timed out\"}\n\n          {:exit, reason} ->\n            Logger.error(\"LLM.call_openai: Task exited: #{inspect(reason)}\")\n            {:error, \"Request task failed\"}\n        end\n\n      Logger.debug(\"LLM.call_openai: Task result: #{inspect(result)}\")\n      result\n    end\n  end\n\n  defp parse_response(json_string, categories) do\n    case Jason.decode(json_string) do\n      {:ok, %{\"category_id\" => category_id, \"summary\" => summary, \"unsubscribe_urls\" => urls}} ->\n        # Validate category_id exists\n        category_ids = Enum.map(categories, fn c -> c.id end)\n\n        if category_id in category_ids do\n          {:ok, %{category_id: category_id, summary: summary, unsubscribe_urls: urls || []}}\n        else\n          # Fallback to first category\n          first_category = List.first(categories)\n\n          {:ok,\n           %{\n             category_id: first_category.id,\n             summary: summary || \"No summary available\",\n             unsubscribe_urls: urls || []\n           }}\n        end\n\n      {:ok, data} ->\n        {:error, \"Invalid response format: #{inspect(data)}\"}\n\n      {:error, reason} ->\n        {:error, \"Failed to parse JSON: #{inspect(reason)}\"}\n    end\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,46,0,null,null,46,46,null,46,null,32,32,null,32,null,28,0,null,null,null,4,null,null,null,null,32,null,null,14,null,null,null,null,null,null,null,null,null,49,null,46,null,null,null,46,46,null,46,null,null,null,46,null,null,46,46,46,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,46,null,46,2,null,null,44,44,null,null,null,44,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,44,44,null,44,null,null,null,null,44,null,44,null,44,null,null,null,null,44,44,null,0,0,null,null,null,0,null,null,null,null,44,null,44,44,null,null,null,null,null,null,32,null,null,null,null,11,3,null,null,null,8,8,null,null,null,1,null,null,null,0,null,null,null,0,null,null,null,44,44,null,null,null,null,32,null,null,28,null,28,27,null,null,1,null,null,null,1,1,1,null,null,null,3,null,null,1,null,null,null,null]},{"name":"lib/emailgator/emails/email.ex","source":"defmodule Emailgator.Emails.Email do\n  use Ecto.Schema\n  import Ecto.Changeset\n  alias Emailgator.Accounts.Account\n  alias Emailgator.Categories.Category\n\n  @primary_key {:id, :binary_id, autogenerate: true}\n  @foreign_key_type :binary_id\n\n  schema \"emails\" do\n    field(:gmail_message_id, :string)\n    field(:subject, :string)\n    field(:from, :string)\n    field(:snippet, :string)\n    field(:summary, :string)\n    field(:body_text, :string)\n    field(:body_html, :string)\n    field(:unsubscribe_urls, {:array, :string}, default: [])\n    field(:archived_at, :utc_datetime)\n    belongs_to(:account, Account)\n    belongs_to(:category, Category)\n\n    has_many(:unsubscribe_attempts, Emailgator.Unsubscribe.UnsubscribeAttempt)\n\n    timestamps()\n  end\n\n  @doc false\n  def changeset(email, attrs) do\n    email\n    |> cast(attrs, [\n      :gmail_message_id,\n      :subject,\n      :from,\n      :snippet,\n      :summary,\n      :body_text,\n      :body_html,\n      :unsubscribe_urls,\n      :archived_at,\n      :account_id,\n      :category_id\n    ])\n    |> validate_required([:gmail_message_id, :account_id])\n    |> unique_constraint([:account_id, :gmail_message_id])\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,1977,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,144,null,null]},{"name":"lib/emailgator_web/router.ex","source":"defmodule EmailgatorWeb.Router do\n  use EmailgatorWeb, :router\n\n  pipeline :api do\n    plug(:accepts, [\"json\"])\n    plug(:ensure_session_fetched)\n    plug(EmailgatorWeb.Schema.Context)\n  end\n\n  defp ensure_session_fetched(conn, _opts) do\n    Plug.Conn.fetch_session(conn)\n  end\n\n  scope \"/api\" do\n    pipe_through(:api)\n\n    forward(\"/graphql\", Absinthe.Plug,\n      schema: EmailgatorWeb.Schema,\n      interface: :playground\n    )\n\n    forward(\"/graphiql\", Absinthe.Plug.GraphiQL,\n      schema: EmailgatorWeb.Schema,\n      interface: :playground\n    )\n  end\n\n  # OAuth routes (user sign-in)\n  scope \"/auth\", EmailgatorWeb do\n    pipe_through(:api)\n\n    get(\"/google\", AuthController, :request)\n    get(\"/google/callback\", AuthController, :callback)\n    get(\"/logout\", AuthController, :delete)\n    post(\"/logout\", AuthController, :delete)\n  end\n\n  # Gmail account connection routes (separate OAuth with Gmail scopes)\n  scope \"/gmail\", EmailgatorWeb do\n    pipe_through(:api)\n\n    get(\"/connect\", GmailController, :connect)\n    get(\"/callback\", GmailController, :callback)\n  end\nend","coverage":[null,null,null,4,null,null,null,null,null,null,4,null,null,null,null,null,4,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,0,0,0,null,null,null,null,null,null,0,0,null,null]},{"name":"lib/emailgator/emails.ex","source":"defmodule Emailgator.Emails do\n  @moduledoc \"\"\"\n  Context for managing emails.\n  \"\"\"\n  import Ecto.Query\n  alias Emailgator.Repo\n  alias Emailgator.Emails.Email\n\n  def list_category_emails(category_id) do\n    from(e in Email, where: e.category_id == ^category_id, order_by: [desc: e.inserted_at])\n    |> Repo.all()\n  end\n\n  def list_account_emails(account_id) do\n    from(e in Email, where: e.account_id == ^account_id, order_by: [desc: e.inserted_at])\n    |> Repo.all()\n  end\n\n  def get_email(id), do: Repo.get(Email, id)\n  def get_email!(id), do: Repo.get!(Email, id)\n\n  def get_email_with_account(id) do\n    from(e in Email, where: e.id == ^id, preload: [:account])\n    |> Repo.one()\n  end\n\n  def get_email_by_gmail_id(account_id, gmail_message_id) do\n    Repo.get_by(Email, account_id: account_id, gmail_message_id: gmail_message_id)\n  end\n\n  def create_email(attrs \\\\ %{}) do\n    %Email{}\n    |> Email.changeset(attrs)\n    |> Repo.insert()\n  end\n\n  def update_email(%Email{} = email, attrs) do\n    email\n    |> Email.changeset(attrs)\n    |> Repo.update()\n  end\n\n  def delete_email(%Email{} = email) do\n    Repo.delete(email)\n  end\n\n  def delete_emails(ids) when is_list(ids) do\n    from(e in Email, where: e.id in ^ids)\n    |> Repo.delete_all()\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,8,null,null,null,null,7,null,null,18,2,null,null,null,25,null,null,null,76,null,null,null,null,null,136,null,null,null,null,null,8,null,null,null,2,null,null,null,null,7,null,null]},{"name":"lib/emailgator/gmail.ex","source":"defmodule Emailgator.Gmail do\n  @moduledoc \"\"\"\n  Gmail API client using Tesla.\n  \"\"\"\n  use Tesla\n  alias Emailgator.Accounts.Account\n\n  adapter(Tesla.Adapter.Finch, name: Emailgator.Finch)\n\n  plug(Tesla.Middleware.BaseUrl, \"https://gmail.googleapis.com/gmail/v1\")\n  plug(Tesla.Middleware.JSON)\n  plug(Tesla.Middleware.FollowRedirects, max_redirects: 5)\n\n  @doc \"\"\"\n  List new messages for an account using history API.\n  Returns list of message IDs that are new since last_history_id.\n  \"\"\"\n  def list_new_message_ids(%Account{} = account) do\n    require Logger\n\n    Logger.info(\n      \"Gmail.list_new_message_ids: Called for account #{account.id}, last_history_id: #{inspect(account.last_history_id)}\"\n    )\n\n    result =\n      case account.last_history_id do\n        nil ->\n          # First time - get all messages\n          Logger.info(\"Gmail.list_new_message_ids: No history_id, fetching recent messages\")\n          list_recent_messages(account)\n\n        history_id ->\n          # Get messages since last history ID\n          Logger.info(\"Gmail.list_new_message_ids: Using history_id #{history_id}\")\n          list_history(account, history_id)\n      end\n\n    case result do\n      {:ok, _, _} = ok ->\n        ok\n\n      {:error, reason} = error ->\n        Logger.error(\n          \"Gmail.list_new_message_ids: Error for account #{account.id}: #{inspect(reason)}\"\n        )\n\n        error\n    end\n  end\n\n  @doc \"\"\"\n  Get message metadata and body.\n  \"\"\"\n  def get_message(account_id, message_id) do\n    require Logger\n    Logger.info(\"Gmail.get_message: Fetching message #{message_id} for account #{account_id}\")\n\n    headers = auth_headers(account_id)\n\n    if Enum.empty?(headers) do\n      Logger.error(\"Gmail.get_message: No auth headers - cannot make request\")\n      {:error, \"Authentication failed: no valid access token\"}\n    else\n      Logger.info(\"Gmail.get_message: Making API request with auth headers (timeout: 15s)\")\n\n      # Use Task with timeout to prevent hanging requests\n      task =\n        Task.async(fn ->\n          try do\n            result = get(\"/users/me/messages/#{message_id}\", headers: headers)\n            Logger.debug(\"Gmail.get_message: Request completed in Task\")\n            result\n          rescue\n            e ->\n              Logger.error(\"Gmail.get_message: Exception in Task: #{inspect(e)}\")\n              {:error, inspect(e)}\n          catch\n            :exit, reason ->\n              Logger.error(\"Gmail.get_message: Task exited: #{inspect(reason)}\")\n              {:error, inspect(reason)}\n          end\n        end)\n\n      Logger.debug(\"Gmail.get_message: Waiting for Task with 15s timeout...\")\n\n      result =\n        case Task.yield(task, 15_000) || Task.shutdown(task) do\n          {:ok, {:ok, %Tesla.Env{status: 200, body: body}}} ->\n            Logger.info(\"Gmail.get_message: Successfully fetched message #{message_id}\")\n            {:ok, body}\n\n          {:ok, {:ok, %Tesla.Env{status: status, body: body}}} ->\n            Logger.error(\n              \"Gmail.get_message: Failed to get message: status #{status}, body: #{inspect(body)}\"\n            )\n\n            {:error, \"Gmail API error: #{status}\"}\n\n          {:ok, {:error, reason}} ->\n            Logger.error(\"Gmail.get_message: Request error: #{inspect(reason)}\")\n            {:error, reason}\n\n          nil ->\n            Logger.error(\"Gmail.get_message: Request timed out after 15 seconds\")\n            {:error, \"Request timed out\"}\n\n          {:exit, reason} ->\n            Logger.error(\"Gmail.get_message: Task exited: #{inspect(reason)}\")\n            {:error, \"Request task failed\"}\n        end\n\n      Logger.debug(\"Gmail.get_message: Task result: #{inspect(result)}\")\n      result\n    end\n  end\n\n  @doc \"\"\"\n  Archive a message in Gmail.\n  \"\"\"\n  def archive_message(account_id, message_id) do\n    require Logger\n\n    Logger.info(\n      \"Gmail.archive_message: Archiving message #{message_id} for account #{account_id}\"\n    )\n\n    headers = auth_headers(account_id)\n\n    if Enum.empty?(headers) do\n      Logger.error(\"Gmail.archive_message: No auth headers - cannot make request\")\n      {:error, \"Authentication failed: no valid access token\"}\n    else\n      Logger.info(\"Gmail.archive_message: Making API request with auth headers (timeout: 15s)\")\n\n      # Use Task with timeout to prevent hanging requests\n      task =\n        Task.async(fn ->\n          try do\n            result =\n              post(\n                \"/users/me/messages/#{message_id}/modify\",\n                %{removeLabelIds: [\"INBOX\"]},\n                headers: headers\n              )\n\n            Logger.debug(\"Gmail.archive_message: Request completed in Task\")\n            result\n          rescue\n            e ->\n              Logger.error(\"Gmail.archive_message: Exception in Task: #{inspect(e)}\")\n              {:error, inspect(e)}\n          catch\n            :exit, reason ->\n              Logger.error(\"Gmail.archive_message: Task exited: #{inspect(reason)}\")\n              {:error, inspect(reason)}\n          end\n        end)\n\n      Logger.debug(\"Gmail.archive_message: Waiting for Task with 15s timeout...\")\n\n      result =\n        case Task.yield(task, 15_000) || Task.shutdown(task) do\n          {:ok, {:ok, %Tesla.Env{status: 200}}} ->\n            Logger.info(\"Gmail.archive_message: Successfully archived message #{message_id}\")\n            {:ok, :archived}\n\n          {:ok, {:ok, %Tesla.Env{status: status, body: body}}} ->\n            Logger.error(\n              \"Gmail.archive_message: Failed to archive: status #{status}, body: #{inspect(body)}\"\n            )\n\n            {:error, \"Failed to archive: #{status}\"}\n\n          {:ok, {:error, reason}} ->\n            Logger.error(\"Gmail.archive_message: Request error: #{inspect(reason)}\")\n            {:error, reason}\n\n          nil ->\n            Logger.error(\"Gmail.archive_message: Request timed out after 15 seconds\")\n            {:error, \"Request timed out\"}\n\n          {:exit, reason} ->\n            Logger.error(\"Gmail.archive_message: Task exited: #{inspect(reason)}\")\n            {:error, \"Request task failed\"}\n        end\n\n      Logger.debug(\"Gmail.archive_message: Task result: #{inspect(result)}\")\n      result\n    end\n  end\n\n  @doc \"\"\"\n  Refresh access token using refresh token.\n  Uses Finch directly for OAuth token refresh (simpler than Tesla for this case).\n  \"\"\"\n  def refresh_token(%Account{} = account) do\n    require Logger\n    Logger.info(\"Gmail.refresh_token: Starting token refresh for account #{account.id}\")\n\n    url = \"https://oauth2.googleapis.com/token\"\n    client_id = System.get_env(\"GOOGLE_CLIENT_ID\")\n    client_secret = System.get_env(\"GOOGLE_CLIENT_SECRET\")\n\n    Logger.debug(\n      \"Gmail.refresh_token: Using client_id: #{if client_id, do: String.slice(client_id, 0..10) <> \"...\", else: \"nil\"}\"\n    )\n\n    if is_nil(account.refresh_token) do\n      Logger.error(\"Gmail.refresh_token: Account #{account.id} has no refresh_token\")\n      {:error, \"No refresh token available\"}\n    else\n      if is_nil(client_id) or is_nil(client_secret) do\n        Logger.error(\"Gmail.refresh_token: Missing GOOGLE_CLIENT_ID or GOOGLE_CLIENT_SECRET\")\n        {:error, \"Missing OAuth credentials\"}\n      else\n        # Build form-encoded body for OAuth token refresh\n        body =\n          URI.encode_query(%{\n            \"client_id\" => client_id,\n            \"client_secret\" => client_secret,\n            \"refresh_token\" => account.refresh_token,\n            \"grant_type\" => \"refresh_token\"\n          })\n\n        headers = [{\"content-type\", \"application/x-www-form-urlencoded\"}]\n\n        Logger.info(\"Gmail.refresh_token: Making POST request to #{url} (timeout: 10s)\")\n\n        # Use Task with timeout to prevent hanging requests\n        task =\n          Task.async(fn ->\n            Finch.build(:post, url, headers, body)\n            |> Finch.request(Emailgator.Finch, receive_timeout: 10_000)\n          end)\n\n        case Task.yield(task, 10_000) || Task.shutdown(task) do\n          {:ok, {:ok, %Finch.Response{status: 200, body: body_json}}} ->\n            case Jason.decode(body_json) do\n              {:ok, %{\"access_token\" => token, \"expires_in\" => expires_in}} ->\n                Logger.info(\"Gmail.refresh_token: Token refresh successful\")\n                expires_at = DateTime.add(DateTime.utc_now(), expires_in, :second)\n                {:ok, token, expires_at}\n\n              {:ok, body_map} ->\n                Logger.error(\n                  \"Gmail.refresh_token: Unexpected response body: #{inspect(body_map)}\"\n                )\n\n                {:error, \"Token refresh failed: unexpected response format\"}\n\n              {:error, decode_error} ->\n                Logger.error(\n                  \"Gmail.refresh_token: Failed to decode JSON response: #{inspect(decode_error)}\"\n                )\n\n                {:error, \"Token refresh failed: invalid JSON response\"}\n            end\n\n          {:ok, {:ok, %Finch.Response{status: status, body: body_json}}} ->\n            case Jason.decode(body_json) do\n              {:ok, body_map} ->\n                Logger.error(\n                  \"Gmail.refresh_token: Token refresh failed with status #{status}: #{inspect(body_map)}\"\n                )\n\n                {:error, \"Token refresh failed: #{inspect(body_map)}\"}\n\n              {:error, _} ->\n                Logger.error(\n                  \"Gmail.refresh_token: Token refresh failed with status #{status}: #{body_json}\"\n                )\n\n                {:error, \"Token refresh failed: status #{status}\"}\n            end\n\n          {:ok, {:error, reason}} ->\n            Logger.error(\"Gmail.refresh_token: Request error: #{inspect(reason)}\")\n            {:error, reason}\n\n          nil ->\n            Logger.error(\"Gmail.refresh_token: Request timed out after 10 seconds\")\n            {:error, \"Token refresh timed out\"}\n\n          {:exit, reason} ->\n            Logger.error(\"Gmail.refresh_token: Task exited: #{inspect(reason)}\")\n            {:error, \"Token refresh task failed\"}\n        end\n      end\n    end\n  end\n\n  # Private helpers\n\n  defp list_recent_messages(%Account{} = account) do\n    require Logger\n    Logger.info(\"Gmail.list_recent_messages: Fetching recent messages for account #{account.id}\")\n\n    headers = auth_headers(account.id)\n\n    if Enum.empty?(headers) do\n      Logger.error(\"Gmail.list_recent_messages: No auth headers - cannot make request\")\n      {:error, \"Authentication failed: no valid access token\"}\n    else\n      Logger.info(\n        \"Gmail.list_recent_messages: Making API request with auth headers (timeout: 15s)\"\n      )\n\n      # Use Task with timeout to prevent hanging requests\n      task =\n        Task.async(fn ->\n          try do\n            result = get(\"/users/me/messages?maxResults=5&q=in:inbox\", headers: headers)\n            Logger.debug(\"Gmail.list_recent_messages: Request completed in Task\")\n            result\n          rescue\n            e ->\n              Logger.error(\"Gmail.list_recent_messages: Exception in Task: #{inspect(e)}\")\n              {:error, inspect(e)}\n          catch\n            :exit, reason ->\n              Logger.error(\"Gmail.list_recent_messages: Task exited: #{inspect(reason)}\")\n              {:error, inspect(reason)}\n          end\n        end)\n\n      Logger.debug(\"Gmail.list_recent_messages: Waiting for Task with 15s timeout...\")\n\n      result =\n        case Task.yield(task, 15_000) || Task.shutdown(task) do\n          {:ok, {:ok, %Tesla.Env{status: 200, body: body}}} ->\n            messages = body[\"messages\"] || []\n            message_ids = Enum.map(messages, & &1[\"id\"]) |> Enum.reject(&is_nil/1)\n\n            Logger.info(\n              \"Gmail.list_recent_messages: Found #{length(message_ids)} message(s) in inbox\"\n            )\n\n            # Get current historyId from profile API for tracking future changes\n            history_id = get_current_history_id(account.id, headers)\n\n            {:ok, message_ids, history_id}\n\n          {:ok, {:ok, %Tesla.Env{status: status, body: body}}} ->\n            Logger.error(\n              \"Gmail.list_recent_messages: Failed to list messages: status #{status}, body: #{inspect(body)}\"\n            )\n\n            {:error, \"Failed to list messages: #{status}\"}\n\n          {:ok, {:error, reason}} ->\n            Logger.error(\"Gmail.list_recent_messages: Request error: #{inspect(reason)}\")\n            {:error, reason}\n\n          nil ->\n            Logger.error(\"Gmail.list_recent_messages: Request timed out after 15 seconds\")\n            {:error, \"Request timed out\"}\n\n          {:exit, reason} ->\n            Logger.error(\"Gmail.list_recent_messages: Task exited: #{inspect(reason)}\")\n            {:error, \"Request task failed\"}\n        end\n\n      Logger.debug(\"Gmail.list_recent_messages: Task result: #{inspect(result)}\")\n      result\n    end\n  end\n\n  defp get_current_history_id(_account_id, headers) do\n    require Logger\n    Logger.info(\"Gmail.get_current_history_id: Fetching current historyId from profile\")\n\n    # Use Task with timeout to prevent hanging requests\n    task =\n      Task.async(fn ->\n        try do\n          result = get(\"/users/me/profile\", headers: headers)\n          Logger.debug(\"Gmail.get_current_history_id: Request completed in Task\")\n          result\n        rescue\n          e ->\n            Logger.error(\"Gmail.get_current_history_id: Exception in Task: #{inspect(e)}\")\n            {:error, inspect(e)}\n        catch\n          :exit, reason ->\n            Logger.error(\"Gmail.get_current_history_id: Task exited: #{inspect(reason)}\")\n            {:error, inspect(reason)}\n        end\n      end)\n\n    Logger.debug(\"Gmail.get_current_history_id: Waiting for Task with 10s timeout...\")\n\n    result =\n      case Task.yield(task, 10_000) || Task.shutdown(task) do\n        {:ok, {:ok, %Tesla.Env{status: 200, body: body}}} ->\n          history_id = body[\"historyId\"]\n          Logger.info(\"Gmail.get_current_history_id: Got current historyId: #{history_id}\")\n          history_id\n\n        {:ok, {:ok, %Tesla.Env{status: status, body: body}}} ->\n          Logger.warning(\n            \"Gmail.get_current_history_id: Failed to get profile: status #{status}, body: #{inspect(body)}\"\n          )\n\n          nil\n\n        {:ok, {:error, reason}} ->\n          Logger.warning(\"Gmail.get_current_history_id: Request error: #{inspect(reason)}\")\n          nil\n\n        nil ->\n          Logger.warning(\"Gmail.get_current_history_id: Request timed out after 10 seconds\")\n          nil\n\n        {:exit, reason} ->\n          Logger.warning(\"Gmail.get_current_history_id: Task exited: #{inspect(reason)}\")\n          nil\n      end\n\n    Logger.debug(\"Gmail.get_current_history_id: Result: #{inspect(result)}\")\n    result\n  end\n\n  defp list_history(%Account{} = account, history_id) do\n    require Logger\n\n    Logger.info(\n      \"Gmail.list_history: Fetching history since history_id: #{history_id} for account #{account.id}\"\n    )\n\n    headers = auth_headers(account.id)\n\n    if Enum.empty?(headers) do\n      Logger.error(\"Gmail.list_history: No auth headers - cannot make request\")\n      {:error, \"Authentication failed: no valid access token\"}\n    else\n      Logger.info(\"Gmail.list_history: Making API request with auth headers (timeout: 15s)\")\n\n      # Use Task with timeout to prevent hanging requests\n      task =\n        Task.async(fn ->\n          try do\n            result =\n              get(\n                \"/users/me/history?historyTypes=messageAdded&startHistoryId=#{history_id}\",\n                headers: headers\n              )\n\n            Logger.debug(\"Gmail.list_history: Request completed in Task\")\n            result\n          rescue\n            e ->\n              Logger.error(\"Gmail.list_history: Exception in Task: #{inspect(e)}\")\n              {:error, inspect(e)}\n          catch\n            :exit, reason ->\n              Logger.error(\"Gmail.list_history: Task exited: #{inspect(reason)}\")\n              {:error, inspect(reason)}\n          end\n        end)\n\n      Logger.debug(\"Gmail.list_history: Waiting for Task with 15s timeout...\")\n\n      result =\n        case Task.yield(task, 15_000) || Task.shutdown(task) do\n          {:ok, {:ok, %Tesla.Env{status: 200, body: body}}} ->\n            history = body[\"history\"] || []\n            Logger.info(\"Gmail.list_history: Received #{length(history)} history entry(ies)\")\n\n            message_ids =\n              history\n              |> Enum.flat_map(&(&1[\"messagesAdded\"] || []))\n              |> Enum.map(& &1[\"message\"][\"id\"])\n              |> Enum.reject(&is_nil/1)\n              |> Enum.uniq()\n\n            new_history_id = extract_latest_history_id(history) || history_id\n\n            Logger.info(\n              \"Gmail.list_history: Found #{length(message_ids)} new message(s), using history_id: #{new_history_id}\"\n            )\n\n            {:ok, message_ids, new_history_id}\n\n          {:ok, {:ok, %Tesla.Env{status: 404}}} ->\n            Logger.warning(\n              \"Gmail.list_history: History ID #{history_id} not found (expired), starting fresh\"\n            )\n\n            # History ID not found, start fresh\n            list_recent_messages(account)\n\n          {:ok, {:ok, %Tesla.Env{status: status, body: body}}} ->\n            Logger.error(\n              \"Gmail.list_history: Failed to get history: status #{status}, body: #{inspect(body)}\"\n            )\n\n            {:error, \"Failed to get history: #{status}\"}\n\n          {:ok, {:error, reason}} ->\n            Logger.error(\"Gmail.list_history: Request error: #{inspect(reason)}\")\n            {:error, reason}\n\n          nil ->\n            Logger.error(\"Gmail.list_history: Request timed out after 15 seconds\")\n            {:error, \"Request timed out\"}\n\n          {:exit, reason} ->\n            Logger.error(\"Gmail.list_history: Task exited: #{inspect(reason)}\")\n            {:error, \"Request task failed\"}\n        end\n\n      Logger.debug(\"Gmail.list_history: Task result: #{inspect(result)}\")\n      result\n    end\n  end\n\n  defp extract_latest_history_id(history) when is_list(history) and length(history) > 0 do\n    history\n    |> Enum.map(& &1[\"id\"])\n    |> Enum.reject(&is_nil/1)\n    |> case do\n      [] -> nil\n      ids -> Enum.max(ids)\n    end\n  end\n\n  defp extract_latest_history_id(_), do: nil\n\n  defp auth_headers(account_id) do\n    require Logger\n    Logger.info(\"Gmail.auth_headers: Called for account_id: #{account_id}, getting token...\")\n\n    case Emailgator.Accounts.get_account_with_valid_token(account_id) do\n      {:ok, account} ->\n        if account.access_token do\n          Logger.info(\"Gmail.auth_headers: Got valid token for account #{account_id}\")\n          [{\"Authorization\", \"Bearer #{account.access_token}\"}]\n        else\n          Logger.error(\"Gmail.auth_headers: Account #{account_id} has no access_token\")\n          []\n        end\n\n      {:error, reason} ->\n        Logger.error(\n          \"Gmail.auth_headers: Failed to get valid token for account #{account_id}: #{inspect(reason)}\"\n        )\n\n        []\n\n      nil ->\n        Logger.error(\"Gmail.auth_headers: Account #{account_id} not found\")\n        []\n    end\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,25,0,null,null,25,25,null,null,12,12,null,null,null,13,13,null,null,25,null,22,null,null,3,3,null,null,3,null,null,null,null,null,null,null,null,43,null,43,null,43,3,null,null,40,null,null,40,null,40,40,40,40,null,0,0,null,null,null,0,null,null,null,null,40,null,40,40,null,35,null,null,null,5,5,null,null,5,null,null,0,null,null,null,0,null,null,null,0,null,null,null,40,40,null,null,null,null,null,null,null,null,null,11,0,null,null,11,null,11,0,null,null,11,null,null,11,null,11,11,null,11,null,null,null,null,11,11,null,0,0,null,null,null,0,null,null,null,null,11,null,11,11,null,7,null,null,null,4,4,null,null,4,null,null,0,null,null,null,0,null,null,null,0,null,null,null,11,11,null,null,null,null,null,null,null,null,null,12,null,12,12,12,null,12,0,null,null,12,0,null,null,12,2,null,null,null,10,null,null,null,10,null,null,null,10,null,10,null,null,10,null,null,10,null,null,10,null,0,null,0,0,0,null,null,0,null,null,null,null,null,null,0,null,null,null,null,null,null,null,10,null,10,10,null,null,null,null,null,0,0,null,null,0,null,null,null,0,null,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,15,null,15,null,15,0,null,null,15,null,null,null,null,15,null,15,15,15,15,null,0,0,null,null,null,0,null,null,null,null,15,null,15,15,null,12,12,null,12,0,null,null,null,12,null,12,null,null,3,3,null,null,3,null,null,0,null,null,null,0,null,null,null,0,null,null,null,15,15,null,null,null,null,null,12,null,null,12,null,12,12,12,12,null,0,0,null,null,null,0,null,null,null,null,12,null,12,12,null,12,12,12,null,null,0,0,null,null,null,null,null,0,null,null,null,0,null,null,null,0,null,null,null,12,12,null,null,null,null,null,13,0,null,null,13,null,13,0,null,null,13,null,null,13,null,13,13,null,13,null,null,null,13,13,null,0,0,null,null,null,0,null,null,null,null,13,null,13,13,null,10,10,null,10,null,13,5,5,null,null,10,null,10,0,null,null,10,null,null,3,3,null,null,null,3,null,null,0,0,null,null,0,null,null,0,null,null,null,0,null,null,null,0,null,null,null,13,13,null,null,null,null,null,13,13,7,0,7,null,null,null,3,null,null,null,82,null,82,null,79,79,79,null,0,null,null,null,null,2,2,null,null,null,null,null,1,null,null,null,null]},{"name":"lib/emailgator_web/schema/types.ex","source":"defmodule EmailgatorWeb.Schema.Types do\n  use Absinthe.Schema.Notation\n  alias Jason\n\n  scalar :datetime do\n    description(\"ISO8601 datetime\")\n    serialize(&serialize_datetime/1)\n    parse(&parse_datetime/1)\n  end\n\n  scalar :json do\n    description(\"JSON object\")\n    serialize(&serialize_json/1)\n    parse(&parse_json/1)\n  end\n\n  object :user do\n    field(:id, :id)\n    field(:email, :string)\n    field(:name, :string)\n    field(:inserted_at, :datetime)\n    field(:updated_at, :datetime)\n  end\n\n  object :account do\n    field(:id, :id)\n    field(:email, :string)\n    field(:inserted_at, :datetime)\n    field(:updated_at, :datetime)\n  end\n\n  object :category do\n    field(:id, :id)\n    field(:name, :string)\n    field(:description, :string)\n    field(:inserted_at, :datetime)\n    field(:updated_at, :datetime)\n  end\n\n  object :email do\n    field(:id, :id)\n    field(:gmail_message_id, :string)\n    field(:subject, :string)\n    field(:from, :string)\n    field(:snippet, :string)\n    field(:summary, :string)\n    field(:body_text, :string)\n    field(:body_html, :string)\n    field(:unsubscribe_urls, list_of(:string))\n    field(:archived_at, :datetime)\n    field(:inserted_at, :datetime)\n    field(:updated_at, :datetime)\n    field(:category, :category)\n\n    field(:is_unsubscribed, :boolean,\n      resolve: &EmailgatorWeb.Schema.Resolvers.Email.is_unsubscribed/3\n    )\n\n    field(:unsubscribe_attempts, list_of(:unsubscribe_attempt),\n      resolve: &EmailgatorWeb.Schema.Resolvers.Email.unsubscribe_attempts/3\n    )\n  end\n\n  object :unsubscribe_result do\n    field(:email_id, :id)\n    field(:success, :boolean)\n    field(:error, :string)\n  end\n\n  object :unsubscribe_attempt do\n    field(:id, :id)\n    field(:method, :string)\n    field(:url, :string)\n    field(:status, :string)\n    field(:evidence, :json)\n    field(:inserted_at, :datetime)\n    field(:updated_at, :datetime)\n  end\n\n  # Serialize DateTime or NaiveDateTime to ISO8601 string\n  defp serialize_datetime(%DateTime{} = datetime) do\n    DateTime.to_iso8601(datetime)\n  end\n\n  defp serialize_datetime(%NaiveDateTime{} = naive_datetime) do\n    # Convert NaiveDateTime to DateTime in UTC (Ecto stores in UTC)\n    naive_datetime\n    |> DateTime.from_naive!(\"Etc/UTC\")\n    |> DateTime.to_iso8601()\n  end\n\n  defp serialize_datetime(nil), do: nil\n  defp serialize_datetime(_), do: nil\n\n  defp parse_datetime(%Absinthe.Blueprint.Input.String{value: value}) do\n    case DateTime.from_iso8601(value) do\n      {:ok, datetime, _} -> {:ok, datetime}\n      _ -> :error\n    end\n  end\n\n  defp parse_datetime(%Absinthe.Blueprint.Input.Null{}) do\n    {:ok, nil}\n  end\n\n  defp parse_datetime(_) do\n    :error\n  end\n\n  # JSON scalar serialization\n  defp serialize_json(value) when is_map(value) or is_list(value) do\n    value\n  end\n\n  defp serialize_json(value) when is_binary(value) do\n    # If it's already a JSON string, try to parse it first\n    case Jason.decode(value) do\n      {:ok, parsed} -> parsed\n      {:error, _} -> value\n    end\n  end\n\n  defp serialize_json(nil), do: nil\n  defp serialize_json(value), do: value\n\n  defp parse_json(%Absinthe.Blueprint.Input.String{value: value}) do\n    case Jason.decode(value) do\n      {:ok, parsed} -> {:ok, parsed}\n      {:error, _} -> :error\n    end\n  end\n\n  defp parse_json(%Absinthe.Blueprint.Input.Null{}) do\n    {:ok, nil}\n  end\n\n  defp parse_json(_) do\n    :error\n  end\nend","coverage":[null,null,null,null,null,null,0,0,null,null,null,null,0,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,0,null,null,0,0,null,null,0,0,0,null,null,null,0,null,null,null,0,null,null,null,null,null,0,null,null,null,null,0,0,0,null,null,null,0,0,null,null,0,0,0,null,null,null,0,null,null,null,0,null,null,null]}]}